diff --git a/.gitignore b/.gitignore
index f791031..7655716 100644
--- a/.gitignore
+++ b/.gitignore
@@ -14,7 +14,6 @@ build/
 *.pyc
 *.swp
 *.bak
-.DS_Store
 .atom/
 .buildlog/
 .history
@@ -25,7 +24,6 @@ Tempfiles/
 *.iml
 *.ipr
 *.iws
-.idea/
 
 # Visual Studio Code related
 .classpath
@@ -53,13 +51,9 @@ version
 
 # Flutter/Dart/Pub related
 **/doc/api/
-.dart_tool/
 .flutter-plugins
 .flutter-plugins-dependencies
-.packages
 .pub-cache/
-.pub/
-build/
 flutter_*.png
 linked_*.ds
 unlinked.ds
@@ -122,4 +116,6 @@ app.*.symbols
 !**/ios/**/default.pbxuser
 !**/ios/**/default.perspectivev3
 !/packages/flutter_tools/test/data/dart_dependencies_test/**/.packages
-!/dev/ci/**/Gemfile.lock
\ No newline at end of file
+!/dev/ci/**/Gemfile.lock
+/.gradle/
+/media3-migration.sh
diff --git a/android/build.gradle.kts b/android/build.gradle.kts
index e69de29..e050509 100644
--- a/android/build.gradle.kts
+++ b/android/build.gradle.kts
@@ -0,0 +1,93 @@
+//import com.android.build.api.dsl.Packaging
+
+plugins {
+    id("com.android.library")
+    id("org.jetbrains.kotlin.android")
+    id("dev.flutter.flutter-gradle-plugin")
+}
+
+group = "com.github.florent37.assetsaudioplayer"
+version = "1.0-SNAPSHOT"
+
+android {
+    namespace = "com.github.florent37.assets_audio_player"
+    compileSdk = 33
+    ndkVersion = "27.0.12077973"
+
+    extensions.findByName("flutter")?.let { flutterExtension ->
+    }
+
+    defaultConfig {
+        minSdk = 33
+        multiDexEnabled = true
+        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+    }
+    //compileSdkVersion(flutter.compileSdkVersion)
+    //ndkVersion = flutter.ndkVersion
+
+    compileOptions {
+        sourceCompatibility = JavaVersion.VERSION_1_8
+        targetCompatibility = JavaVersion.VERSION_1_8
+    }
+
+    //Eirik 16.03.25: Added to set Kotlin compilation to same as Java
+    kotlinOptions {
+        //jvmTarget = JavaVersion.VERSION_1_8.toString()
+        jvmTarget = "1.8"
+    }
+
+    sourceSets {
+        getByName("main") {
+            java.srcDirs("src/main/kotlin")
+        }
+    }
+
+    lint {
+        disable += "InvalidPackage"
+    }
+    //Eirik 23.05.25: Changed for temporary downgrade of AGP
+    //packaging {
+    packagingOptions {
+        resources.excludes += "DebugProbesKt.bin"
+    }
+
+
+    //compileSdkVersion(providers.provider { flutter.compileSdkVersion }.get())
+    //ndkVersion = providers.provider { flutter.ndkVersion }.get()
+}
+
+dependencies {
+    val coroutinesVersion = "1.6.4"
+    //val media3Version = "1.6.1"
+    val media3Version = "1.1.1"
+    val glideVersion = "4.14.2"
+
+    // ADD THIS LINE:
+    // Use compileOnly if you expect the consuming app to always provide it at runtime.
+    // Use implementation for this test if you want to ensure it's definitely packaged.
+    // For plugin development, compileOnly is often preferred for Flutter dependencies.
+    //compileOnly("io.flutter:flutter_embedding_debug:1.0.0-edd8546116457bdf1c5bdfb13ecb9463d2bb5ed4")
+    // If compileOnly doesn't resolve it for compilation in this specific scenario,
+    // try implementation temporarily for the test, but compileOnly is more typical for plugins.
+    // implementation("io.flutter:flutter_embedding_debug:1.0.0-<flutter_sdk_version_hash>")
+
+    implementation("org.jetbrains.kotlin:kotlin-stdlib")
+    implementation("androidx.multidex:multidex:2.0.1")
+    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutinesVersion")
+    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutinesVersion")
+    //implementation("androidx.annotation:annotation:1.9.1") //Eirik 18.09.24: Now same as assets_audio_player_web
+    implementation("androidx.annotation:annotation:1.7.0")
+    //implementation("androidx.core:core-ktx:1.16.0")
+    implementation("androidx.core:core-ktx:1.10.1")
+    implementation("androidx.media3:media3-session:$media3Version")
+    implementation("androidx.media3:media3-common:$media3Version")
+    implementation("androidx.media3:media3-exoplayer:$media3Version")
+    implementation("androidx.media3:media3-exoplayer-hls:$media3Version")
+    implementation("androidx.media3:media3-exoplayer-dash:$media3Version")
+    implementation("androidx.media3:media3-exoplayer-smoothstreaming:$media3Version")
+    implementation("androidx.media3:media3-ui:$media3Version")
+    implementation("com.github.bumptech.glide:glide:$glideVersion")
+    implementation("androidx.concurrent:concurrent-futures:1.2.0")
+    implementation("com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava")
+    annotationProcessor("com.github.bumptech.glide:compiler:$glideVersion")
+}
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index 96a5303..ec20539 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,9 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-#distributionUrl=https\://services.gradle.org/distributions/gradle-6.5-bin.zip
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.10-bin.zip
+#distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-all.zip
+#Eirik 15.05.25: Downgraded flutter from 3.29.2 to 3.22.2 due to error in flutter version
+#Gradle version 8.1 is compatible with Flutter 3.22.2
+#distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.1-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/android/settings.gradle.kts b/android/settings.gradle.kts
index 125d20a..627606e 100644
--- a/android/settings.gradle.kts
+++ b/android/settings.gradle.kts
@@ -1,24 +1,3 @@
-/*import org.gradle.kotlin.dsl.DependencyHandlerScope
-import java.util.Properties
-import kotlin.io.path.exists
-import kotlin.io.path.toPath
-import kotlin.io.resolve
-import kotlin.io.use
-*/
-pluginManagement {
-    repositories {
-        google()
-        mavenCentral()
-        gradlePluginPortal()
-    }
-
-    plugins {
-        id("com.android.application") version "8.0.0" apply false
-        id("com.android.library") version "8.0.0" apply false
-        id("org.jetbrains.kotlin.android") version "1.9.22" apply false
-        //id("dev.flutter.flutter-plugin-loader") version "1.0.0" apply false
-    }
-}
 
 dependencyResolutionManagement {
     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
@@ -27,33 +6,3 @@ dependencyResolutionManagement {
         mavenCentral()
     }
 }
-
-include(":app")
-/* Eirik 03.05.25: Removed this code as there's no ".flutter-plugins" file used in this project
-val flutterProjectRoot = rootProject.projectDir.parentFile.toPath()
-
-val plugins = Properties()
-val pluginsFile = File(flutterProjectRoot.toFile(), ".flutter-plugins")
-if (pluginsFile.exists()) {
-    pluginsFile.reader(Charsets.UTF_8).use { reader ->
-        plugins.load(reader)
-    }
-}
-
-plugins.forEach { name, value ->
-    try {
-        val path = value.toString()
-        val pluginDirectory = flutterProjectRoot.resolve(path).resolve("android").toFile()
-        include(":$name")
-        project(":$name").projectDir = pluginDirectory
-    } catch (e: Exception) {
-        println("Could not find external project: $name")
-        throw e
-    }
-}
-*/
-
-//    val path = value.toString()
-//    val pluginDirectory = flutterProjectRoot.resolve(path).resolve("android").toFile()
-//    include(":$name")
-//    project(":$name").projectDir = pluginDirectory
\ No newline at end of file
diff --git a/android/src/main/AndroidManifest.xml b/android/src/main/AndroidManifest.xml
index 71e9f79..6a22a49 100644
--- a/android/src/main/AndroidManifest.xml
+++ b/android/src/main/AndroidManifest.xml
@@ -1,5 +1,4 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-  package="com.github.florent37.assets_audio_player">
+<manifest xmlns:android="http://schemas.android.com/apk/res/android">
 
     <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
     <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK"/>
diff --git a/android/src/main/kotlin/com/github/florent37/assets_audio_player/AssetsAudioPlayerPlugin.kt b/android/src/main/kotlin/com/github/florent37/assets_audio_player/AssetsAudioPlayerPlugin.kt
index 2062861..4e6f118 100644
--- a/android/src/main/kotlin/com/github/florent37/assets_audio_player/AssetsAudioPlayerPlugin.kt
+++ b/android/src/main/kotlin/com/github/florent37/assets_audio_player/AssetsAudioPlayerPlugin.kt
@@ -12,6 +12,7 @@ import androidx.annotation.NonNull
 //import androidx.compose.ui.graphics.vector.path
 import com.github.florent37.assets_audio_player.headset.HeadsetStrategy
 import com.github.florent37.assets_audio_player.notification.*
+//import com.github.florent37.assets_audio_player.notification.MediaButtonsReceiver
 import com.github.florent37.assets_audio_player.playerimplem.PlayerFinder
 import com.github.florent37.assets_audio_player.stopwhencall.AudioFocusStrategy
 import com.github.florent37.assets_audio_player.stopwhencall.HeadsetManager
@@ -193,6 +194,10 @@ class AssetsAudioPlayer(
 
     private val players = mutableMapOf<String, Player>()
 
+    fun getPlayers(): Map<String, Player> {
+        return players
+    }
+
     fun getPlayer(id: String): Player? {
         return this.players[id]
     }
diff --git a/android/src/main/kotlin/com/github/florent37/assets_audio_player/Player.kt b/android/src/main/kotlin/com/github/florent37/assets_audio_player/Player.kt
index 975330a..3ab3097 100644
--- a/android/src/main/kotlin/com/github/florent37/assets_audio_player/Player.kt
+++ b/android/src/main/kotlin/com/github/florent37/assets_audio_player/Player.kt
@@ -13,8 +13,15 @@ import com.github.florent37.assets_audio_player.notification.NotificationSetting
 import com.github.florent37.assets_audio_player.playerimplem.*
 import com.github.florent37.assets_audio_player.stopwhencall.AudioFocusStrategy
 import com.github.florent37.assets_audio_player.stopwhencall.StopWhenCall
-import io.flutter.embedding.engine.plugins.FlutterPlugin
-import io.flutter.plugin.common.MethodChannel
+//import io.flutter.embedding.engine.plugins.FlutterPlugin
+//import io.flutter.plugin.common.MethodChannel
+import androidx.media3.common.Player // Import the Media3 Player interface
+import androidx.media3.common.Player.Listener
+import android.os.Looper
+import androidx.media3.common.MediaItem
+import androidx.media3.common.PlaybackException
+import androidx.media3.exoplayer.ExoPlayer
+import androidx.media3.common.util.UnstableApi // Import UnstableApi
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.GlobalScope
 import kotlinx.coroutines.launch
@@ -30,7 +37,9 @@ class Player(
         private val stopWhenCall: StopWhenCall,
         private val notificationManager: NotificationManager,
         private val flutterAssets: FlutterPlugin.FlutterAssets
-) {
+) : Player // Implement the Media3 Player interface (unqualified name is fine due to import)
+{
+    // {
 
     companion object {
         const val VOLUME_WHEN_REDUCED = 0.3
@@ -46,7 +55,8 @@ class Player(
     // To handle position updates.
     private val handler = Handler()
 
-    private var mediaPlayer: PlayerImplem? = null
+    //private var mediaPlayer: PlayerImplem? = null
+    private var mediaPlayer: ExoPlayer? = null
 
     //region outputs
     var onVolumeChanged: ((Double) -> Unit)? = null
@@ -100,7 +110,9 @@ class Player(
                         handler.removeCallbacks(this)
                     }
 
-                    val positionMs : Long = mediaPlayer.currentPositionMs
+                    //Probably more correct to use contentPosition instead of currentPosition. Needs to be tested.
+                    //val positionMs : Long = mediaPlayer.currentPosition
+                    val positionMs : Long = mediaPlayer.contentPosition
 
                     if(_lastPositionMs != positionMs) {
                         // Send position (milliseconds) to the application.
@@ -132,7 +144,13 @@ class Player(
         }
     }
 
-    fun next() {
+    @Deprecated(
+        "Use seekToNextMediaItem() instead.", // Provide a message
+        ReplaceWith("seekToNextMediaItem()") // Suggest the replacement
+    )
+    @UnstableApi
+    override fun next() {
+        mediaPlayer?.seekToNextMediaItem()
         this.onNext?.invoke()
     }
 
@@ -199,7 +217,7 @@ class Player(
                         onBuffering = onBuffering,
                         onError= onError,
                         drmConfiguration = drmConfiguration
-                        )
+                        )PlayerImplem
                 )
 
                 val durationMs = playerWithDuration.duration
@@ -266,6 +284,12 @@ class Player(
         }
     }
 
+    // Implement the abstract stop() method from androidx.media3.common.Player
+    override fun stop() {
+        // Call your existing custom stop method with default values
+        this.stop(pingListener = true, removeNotification = true)
+    }
+
 
     fun toggle() {
         if (isPlaying) {
@@ -421,6 +445,10 @@ class Player(
         }
     }
 
+    override fun setVolume(volume: Float) {
+        this.setVolume(volume.toDouble())
+    }
+
     private var forwardHandler: ForwardHandler? = null;
 
     fun setPlaySpeed(playSpeed: Double) {
@@ -532,6 +560,773 @@ class Player(
             }
         }
     }
+
+    // Implement the abstract getApplicationLooper() method from androidx.media3.common.Player
+    override fun getApplicationLooper(): Looper {
+        // Since your player logic seems to run on the main thread,
+        // return the looper of the main thread.
+        return Looper.getMainLooper()
+    }
+
+    // Maintain a list of registered Media3 Player.Listener instances
+    private val media3Listeners = mutableListOf<Player.Listener>()
+
+    // Implement the abstract addListener method from androidx.media3.common.Player
+    override fun addListener(listener: Player.Listener) {
+        // Add the listener to your list
+        media3Listeners.add(listener)
+    }
+
+    // Implement the abstract removeListener method from androidx.media3.common.Player
+    override fun removeListener(listener: Player.Listener) {
+        // Remove the listener from your list
+        media3Listeners.remove(listener)
+    }
+
+    // Example of how to notify listeners when playback state changes:
+    // You would call this from your internal playback logic whenever the state changes
+    fun notifyPlaybackStateChanged(playbackState: Int) {
+        for (listener in media3Listeners) {
+            listener.onPlaybackStateChanged(playbackState)
+        }
+    }
+
+    // Example of how to notify listeners when there's a player error:
+    // You would call this from your internal error handling logic
+    fun notifyPlayerError(error: PlaybackException) {
+        for (listener in media3Listeners) {
+            listener.onPlayerError(error)
+        }
+    }
+
+    // Implement the abstract setMediaItem method from androidx.media3.common.Player
+    override fun setMediaItem(mediaItem: MediaItem) {
+        // Create a list with the single media item and call setMediaItems
+        setMediaItems(mutableListOf(mediaItem))
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare() // Or call prepare in the setMediaItems method you call
+    }
+
+    // This one takes a single MediaItem and a startPositionMs
+    override fun setMediaItem(mediaItem: MediaItem, startPositionMs: Long) {
+        // Create a list with the single media item and call setMediaItems
+        // Use startIndex 0 for a single item
+        setMediaItems(mutableListOf(mediaItem), 0, startPositionMs)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare() // Or call prepare in the setMediaItems method you call
+    }
+
+    // This one takes a single MediaItem and a resetPosition
+    override fun setMediaItem(mediaItem: MediaItem, resetPosition: Boolean) {
+        // Create a list with the single media item and call setMediaItems
+        setMediaItems(mutableListOf(mediaItem), resetPosition)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare() // Or call prepare in the setMediaItems method you call
+    }
+
+    // Implement the abstract setMediaItems method from androidx.media3.common.Player
+    override fun setMediaItems(mediaItems: MutableList<MediaItem>) {
+        // Pass the list of MediaItems to the underlying ExoPlayer
+        mediaPlayer?.setMediaItems(mediaItems)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    // This one takes the list of MediaItems AND the resetPosition boolean
+    override fun setMediaItems(mediaItems: MutableList<MediaItem>, resetPosition: Boolean) {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        mediaPlayer?.setMediaItems(mediaItems, resetPosition)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    // This one takes the list of MediaItems, startIndex, and startPositionMs
+    override fun setMediaItems(mediaItems: MutableList<MediaItem>, startIndex: Int, startPositionMs: Long) {
+        // Pass the list of MediaItems, startIndex, and startPositionMs to the underlying ExoPlayer
+        mediaPlayer?.setMediaItems(mediaItems, startIndex, startPositionMs)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun addMediaItem(mediaItem: MediaItem) {
+        // Create a list with the single media item and call addMediaItems
+        mediaPlayer?.addMediaItem(mediaItem)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare() // Or call prepare in the setMediaItems method you call
+    }
+
+    override fun addMediaItem(index: Int, mediaItem: MediaItem) {
+        // Create a list with the single media item and call addMediaItems
+        mediaPlayer?.addMediaItem(index, mediaItem)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare() // Or call prepare in the setMediaItems method you call
+    }
+
+    // Implement the abstract addMediaItems method from androidx.media3.common.Player
+    override fun addMediaItems(mediaItems: MutableList<MediaItem>) {
+        // Pass the list of MediaItems to the underlying ExoPlayer
+        mediaPlayer?.addMediaItems(mediaItems)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    // This one takes the list of MediaItems AND the resetPosition boolean
+    override fun addMediaItems(index: Int, mediaItems: MutableList<MediaItem>) {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        mediaPlayer?.addMediaItems(index, mediaItems)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun moveMediaItem(currentIndex: Int, newIndex: Int) {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        mediaPlayer?.moveMediaItem(currentIndex, newIndex)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun moveMediaItems(fromIndex: Int, toIndex: Int, newIndex: Int) {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        mediaPlayer?.moveMediaItems(fromIndex, toIndex, newIndex)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun replaceMediaItem(index: Int, mediaItem: MediaItem) {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        mediaPlayer?.replaceMediaItem(index, mediaItem)
+        // Optionally call prepare() here if you want the player to prepare immediately
+    }
+
+    override fun replaceMediaItems(fromIndex: Int, toIndex: Int, mediaItems: MutableList<MediaItem>) {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        mediaPlayer?.replaceMediaItems(fromIndex, toIndex, mediaItems)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun removeMediaItem(index: Int) {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        mediaPlayer?.removeMediaItem(index)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun removeMediaItems(fromIndex: Int, toIndex: Int) {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        mediaPlayer?.removeMediaItems(fromIndex, toIndex)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun clearMediaItems() {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        mediaPlayer?.clearMediaItems()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getMediaItemCount(): Int {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        return mediaPlayer?.mediaItemCount ?: 0
+    }
+
+    override fun isCommandAvailable(command: Int): Boolean {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        return mediaPlayer?.isCommandAvailable(command) ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun canAdvertiseSession(): Boolean {
+        return false
+    }
+
+    override fun getAvailableCommands(): Player.Commands {
+        return mediaPlayer?.getAvailableCommands(Player.Commands) ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    //Class 'Player' is not abstract and does not implement abstract member public
+    //abstract fun prepare(): Unit defined in androidx. media3.common. Player
+    override fun prepare() {
+        // Pass the list of MediaItems and the resetPosition to the underlying ExoPlayer
+        mediaPlayer?.prepare()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getPlaybackState(): Int {
+        return mediaPlayer?.playbackState ?: Player.STATE_IDLE
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getPlaybackSuppressionReason(): Int {
+        return mediaPlayer?.playbackSuppressionReason ?: Player.PLAYBACK_SUPPRESSION_REASON_NONE
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun  isPlaying(): Boolean {
+        return mediaPlayer?.isPlaying ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getPlayerError(): PlaybackException? {
+        return mediaPlayer?.playerError
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setPlayWhenReady(playWhenReady: Boolean): Unit {
+        mediaPlayer?.setPlayWhenReady(playWhenReady)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override  fun getPlayWhenReady(): Boolean {
+        return mediaPlayer?.playWhenReady ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setRepeatMode(repeatMode: Int): Unit {
+        mediaPlayer?.setRepeatMode(repeatMode)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getRepeatMode(): Int {
+        return mediaPlayer?.repeatMode ?: Player.REPEAT_MODE_OFF
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setShuffleModeEnabled(shuffleModeEnabled: Boolean): Unit {
+        mediaPlayer?.setShuffleModeEnabled(shuffleModeEnabled)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getShuffleModeEnabled(): Boolean {
+        return mediaPlayer?.shuffleModeEnabled ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun isLoading(): Boolean {
+        return mediaPlayer?.isLoading ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+
+    }
+
+    override fun seekToDefaultPosition(): Unit {
+        mediaPlayer?.seekToDefaultPosition()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun seekToDefaultPosition(mediaItemIndex: Int): Unit {
+        mediaPlayer?.seekToDefaultPosition(mediaItemIndex)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun seekTo(positionMs: Long): Unit {
+        mediaPlayer?.seekTo(positionMs)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun seekTo(mediaItemIndex: Int, positionMs: Long): Unit {
+        mediaPlayer?.seekTo(mediaItemIndex, positionMs)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override  fun getSeekBackIncrement(): Long {
+        return mediaPlayer?.seekBackIncrement ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun seekBack(): Unit {
+        mediaPlayer?.seekBack()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getSeekForwardIncrement(): Long {
+        return mediaPlayer?.seekForwardIncrement ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun seekForward(): Unit {
+        mediaPlayer?.seekForward()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun hasPreviousMediaItem(): Boolean {
+        return mediaPlayer?.hasPreviousMediaItem() ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+
+    override fun seekToPreviousWindow(): Unit {
+        mediaPlayer?.seekToPreviousWindow()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun seekToNextWindow(): Unit {
+        mediaPlayer?.seekToNextWindow()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override  fun seekToPreviousMediaItem(): Unit {
+        mediaPlayer?.seekToPreviousMediaItem()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getMaxSeekToPreviousPosition(): Long {
+        return mediaPlayer?.maxSeekToPreviousPosition ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun seekToPrevious(): Unit {
+        mediaPlayer?.seekToPrevious()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun hasNext(): Boolean {
+        return mediaPlayer?.hasNext() ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+   override fun hasNextWindow(): Boolean {
+        return mediaPlayer?.hasNextWindow() ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+   }
+
+    override fun hasNextMediaItem(): Boolean {
+        return mediaPlayer?.hasNextMediaItem() ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun seekToNextMediaItem(): Unit {
+        mediaPlayer?.seekToNextMediaItem()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun seekToNext(): Unit {
+        mediaPlayer?.seekToNext()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setPlaybackParameters(playbackParameters: PlaybackParameters): Unit {
+        mediaPlayer?.setPlaybackParameters(playbackParameters)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setPlaybackSpeed(speed: Float): Unit {
+        mediaPlayer?.setPlaybackSpeed(speed)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getPlaybackParameters(): PlaybackParameters {
+        return mediaPlayer?.playbackParameters ?: PlaybackParameters()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun release(): Unit {
+        mediaPlayer?.release()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentTracks(): Tracks {
+        return mediaPlayer?.currentTracks ?: Tracks()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getTrackSelectionParameters(): TrackSelectionParameters {
+        return mediaPlayer?.trackSelectionParameters ?: TrackSelectionParameters()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setTrackSelectionParameters(parameters: TrackSelectionParameters): Unit {
+        mediaPlayer?.setTrackSelectionParameters(parameters)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getMediaMetadata(): MediaMetadata {
+        return mediaPlayer?.mediaMetadata ?: MediaMetadata()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getPlaylistMetadata(): MediaMetadata {
+        return mediaPlayer?.playlistMetadata ?: MediaMetadata()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setPlaylistMetadata(mediaMetadata: MediaMetadata): Unit {
+        mediaPlayer?.setPlaylistMetadata(mediaMetadata)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentManifest(): Any? {
+        return mediaPlayer?.currentManifest
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentTimeline(): Timeline {
+        return mediaPlayer?.currentTimeline ?: Timeline()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentPeriodIndex(): Int {
+        return mediaPlayer?.currentPeriodIndex ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentWindowIndex(): Int {
+        return mediaPlayer?.currentWindowIndex ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentMediaItemIndex(): Int {
+        return mediaPlayer?.currentMediaItemIndex ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getNextWindowIndex(): Int {
+        return mediaPlayer?.nextWindowIndex ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getNextMediaItemIndex(): Int {
+        return mediaPlayer?.nextMediaItemIndex ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getPreviousWindowIndex(): Int {
+        return mediaPlayer?.previousWindowIndex ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getPreviousMediaItemIndex(): Int {
+        return mediaPlayer?.previousMediaItemIndex ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentMediaItem(): MediaItem? {
+        return mediaPlayer?.currentMediaItem
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getMediaItemAt(index: Int): MediaItem {
+        return mediaPlayer?.getMediaItemAt(index) ?: MediaItem()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getDuration(): Long {
+        return mediaPlayer?.duration ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentPosition(): Long {
+        return mediaPlayer?.currentPosition ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getBufferedPosition(): Long {
+        return mediaPlayer?.bufferedPosition ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getBufferedPercentage(): Int {
+        return mediaPlayer?.bufferedPercentage ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getTotalBufferedDuration(): Long {
+        return mediaPlayer?.totalBufferedDuration ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun isCurrentWindowDynamic(): Boolean {
+        return mediaPlayer?.isCurrentWindowDynamic ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun isCurrentMediaItemDynamic(): Boolean {
+        return mediaPlayer?.isCurrentMediaItemDynamic ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun isCurrentWindowLive(): Boolean {
+        return mediaPlayer?.isCurrentWindowLive ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun isCurrentMediaItemLive(): Boolean {
+        return mediaPlayer?.isCurrentMediaItemLive ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentLiveOffset(): Long {
+        return mediaPlayer?.currentLiveOffset ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun isCurrentWindowSeekable(): Boolean {
+        return mediaPlayer?.isCurrentWindowSeekable ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun isCurrentMediaItemSeekable(): Boolean {
+        return mediaPlayer?.isCurrentMediaItemSeekable ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun isPlayingAd(): Boolean {
+        return mediaPlayer?.isPlayingAd ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentAdGroupIndex(): Int {
+        return mediaPlayer?.currentAdGroupIndex ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentAdIndexInAdGroup(): Int {
+        return mediaPlayer?.currentAdIndexInAdGroup ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getContentDuration(): Long {
+        return mediaPlayer?.contentDuration ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getContentPosition(): Long {
+        return mediaPlayer?.contentPosition ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getContentBufferedPosition(): Long {
+        return mediaPlayer?.contentBufferedPosition ?: 0L
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getAudioAttributes(): AudioAttributes {
+        return mediaPlayer?.audioAttributes ?: AudioAttributes()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getVolume(): Float {
+        return mediaPlayer?.volume ?: 0f
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun clearVideoSurface(): Unit {
+        mediaPlayer?.clearVideoSurface()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun clearVideoSurface(surface: Surface?): Unit {
+        mediaPlayer?.clearVideoSurface(surface)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setVideoSurface(surface: Surface?): Unit {
+        mediaPlayer?.setVideoSurface(surface)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setVideoSurfaceHolder(surfaceHolder: SurfaceHolder?): Unit {
+        mediaPlayer?.setVideoSurfaceHolder(surfaceHolder)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun clearVideoSurfaceHolder(surfaceHolder: SurfaceHolder?): Unit {
+        mediaPlayer?.clearVideoSurfaceHolder(surfaceHolder)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setVideoSurfaceView(surfaceView: SurfaceView?): Unit {
+        mediaPlayer?.setVideoSurfaceView(surfaceView)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun clearVideoSurfaceView(surfaceView: SurfaceView?): Unit {
+        mediaPlayer?.clearVideoSurfaceView(surfaceView)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setVideoTextureView(textureView: TextureView?): Unit {
+        mediaPlayer?.setVideoTextureView(textureView)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun clearVideoTextureView(textureView: TextureView?): Unit {
+        mediaPlayer?.clearVideoTextureView(textureView)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getVideoSize(): VideoSize {
+        return mediaPlayer?.videoSize ?: VideoSize()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getSurfaceSize(): Size {
+        return mediaPlayer?.surfaceSize ?: Size()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getCurrentCues(): CueGroup {
+        return mediaPlayer?.currentCues ?: CueGroup()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getDeviceInfo(): DeviceInfo {
+        return mediaPlayer?.deviceInfo ?: DeviceInfo()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun getDeviceVolume(): Int {
+        return mediaPlayer?.deviceVolume ?: 0
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun isDeviceMuted(): Boolean {
+        return mediaPlayer?.isDeviceMuted ?: false
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setDeviceVolume(volume: Int): Unit {
+        mediaPlayer?.setDeviceVolume(volume)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setDeviceVolume(volume: Int, flags: Int): Unit {
+        mediaPlayer?.setDeviceVolume(volume, flags)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override  fun increaseDeviceVolume(): Unit {
+        mediaPlayer?.increaseDeviceVolume()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun increaseDeviceVolume(flags: Int): Unit {
+        mediaPlayer?.increaseDeviceVolume(flags)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun decreaseDeviceVolume(): Unit {
+        mediaPlayer?.decreaseDeviceVolume()
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun decreaseDeviceVolume(flags: Int): Unit {
+        mediaPlayer?.decreaseDeviceVolume(flags)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setDeviceMuted(muted: Boolean): Unit {
+        mediaPlayer?.setDeviceMuted(muted)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setDeviceMuted(muted: Boolean, flags: Int): Unit {
+        mediaPlayer?.setDeviceMuted(muted, flags)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
+
+    override fun setAudioAttributes(audioAttributes: AudioAttributes, handleAudioFocus: Boolean): Unit {
+        mediaPlayer?.setAudioAttributes(audioAttributes, handleAudioFocus)
+        // Optionally call prepare() here if you want the player to prepare immediately
+        // mediaPlayer?.prepare()
+    }
 }
 
 class ForwardHandler : Handler() {
@@ -568,4 +1363,14 @@ class ForwardHandler : Handler() {
             }
         }
     }
-}
\ No newline at end of file
+}
+
+
+
+
+
+
+
+
+
+
diff --git a/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/CustomMediaButtonReceiver.kt b/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/CustomMediaButtonReceiver.kt
index 406b5c8..ee2a368 100644
--- a/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/CustomMediaButtonReceiver.kt
+++ b/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/CustomMediaButtonReceiver.kt
@@ -3,16 +3,31 @@ package com.github.florent37.assets_audio_player.notification
 import android.content.Context
 import android.content.Intent
 import android.util.Log
-import androidx.media.session.MediaButtonReceiver
+//import androidx.media3.session.MediaSession
+import androidx.media3.session.MediaButtonReceiver
 import androidx.annotation.Keep;
 
 @Keep
+
 class CustomMediaButtonReceiver : MediaButtonReceiver() {
-    override fun onReceive(context: Context?, intent: Intent?) {
+    override fun onReceive(context: Context, intent: Intent) {
         try {
+            // Call the superclass's onReceive, which should handle the media button event
+            // and route it correctly within the Media3 framework if a MediaSession is active.
             super.onReceive(context, intent)
         } catch (e: Exception) {
             Log.e(javaClass.name, e.message ?: "unknown error")
         }
     }
+
+}
+/*
+    override fun onReceive(controller: MediaSession.ControllerInfo, intent: Intent) {
+        try {
+            super.onReceive(controller, intent)
+        } catch (e: Exception) {
+            Log.e(javaClass.name, e.message ?: "unknown error")
+        }
+    }
 }
+*/
diff --git a/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/MediaButtonsReceiver.kt b/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/MediaButtonsReceiver.kt
index 5838363..097cfcb 100644
--- a/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/MediaButtonsReceiver.kt
+++ b/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/MediaButtonsReceiver.kt
@@ -3,68 +3,118 @@ package com.github.florent37.assets_audio_player.notification
 import android.content.Context
 import android.content.Intent
 import android.os.Bundle
-/* Eirik 02.04.25: Deprecated Android Support library, replaced by AndroidX equivlants
-import android.support.v4.media.session.MediaControllerCompat
-import android.support.v4.media.session.MediaSessionCompat
-import android.support.v4.media.session.MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS
-import android.support.v4.media.session.PlaybackStateCompat
- */
-import androidX.media.session.MediaControllerCompat
-import androidX.media.session.MediaSessionCompat
-import androidX.media.session.MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS
-import androidX.media.session.PlaybackStateCompat
+//import androidx.media3.session.MediaController
+//import androidx.media3.session.MediaSession
+//import androidx.media3.common.PlaybackState
 import android.view.KeyEvent
-
-class MediaButtonsReceiver(context: Context, private val onAction: (MediaButtonAction) -> Unit, private val onNotifSeek: (Long) -> Unit) {
+//import androidx.concurrent.futures.ResolvableFuture
+import androidx.concurrent.futures.CallbackToFutureAdapter
+//import androidx.media3.common.Player
+//import androidx.media3.common.Player.Listener
+import androidx.media3.exoplayer.ExoPlayer
+import androidx.media3.session.MediaSession
+import androidx.media3.session.SessionCommand
+//import androidx.media3.common.util.ListenableFuture
+import androidx.media3.session.SessionResult
+//import androidx.privacysandbox.tools.core.generator.build
+import com.google.common.util.concurrent.ListenableFuture
+
+@androidx.media3.common.util.UnstableApi
+
+class MediaButtonsReceiver(
+    context: Context,
+    private val onAction: (MediaButtonAction) -> Unit,
+    private val onNotifSeek: (Long) -> Unit
+) {
 
     companion object {
         var instance: MediaButtonsReceiver? = null
 
+        private var mediaSession: MediaSession? = null
 
-        private var mediaSessionCompat : MediaSessionCompat? = null
-        fun getMediaSessionCompat(context: Context) : MediaSessionCompat {
-            if(mediaSessionCompat == null) {
-                mediaSessionCompat = MediaSessionCompat(context, "MediaButtonsReceiver", null, null).apply {
-                    setFlags(FLAG_HANDLES_MEDIA_BUTTONS)
-                    isActive = true
-                }
+        fun getMediaSession(context: Context): MediaSession {
+            if (mediaSession == null) {
+                val player = ExoPlayer.Builder(context).build()
+               //mediaSession = androidx.media3.session.MediaSession.Builder(context,
+               //     androidx.media3.common.Player.Listener { /* empty */ }).build()
+/*
+                mediaSession = MediaSession.Builder(context, player).build()
             }
-            return mediaSessionCompat!!
+            return mediaSession!!
         }
     }
 
-    enum class MediaButtonAction {
-        play, 
-        pause, 
-        playOrPause, 
-        next, 
-        prev, 
-        stop
-    }
+
 
     init {
         instance = this
+        getMediaSession(context).setCallback(mediaSessionCallback)
     }
 
-    private val mediaSessionCallback = object : MediaSessionCompat.Callback() {
-        override fun onMediaButtonEvent(mediaButtonEvent: Intent?): Boolean {
-            onIntentReceive(mediaButtonEvent)
-            return super.onMediaButtonEvent(mediaButtonEvent)
-        }
+                private val mediaSessionCallback = object : MediaSession.Callback {*/
+
+                val mediaSessionCallback = object : MediaSession.Callback {
+                    override fun onMediaButtonEvent(
+                        mediaSession: MediaSession,
+                        controller: MediaSession.ControllerInfo,
+                        intent: Intent
+                    ): Boolean {
+                        //onIntentReceive(intent)
+                        instance?.onIntentReceive(intent)
+                        return true
+                    }
+
+                    override fun onCustomCommand(
+                        mediaSession: MediaSession,
+                        controller: MediaSession.ControllerInfo,
+                        customCommand: SessionCommand,
+                        args: Bundle
+//        ): ListenableFuture<SessionResult> {
+//            //return super.onCustomCommand(controller, customCommand, args)
+//            return androidx.media3.common.util.Futures.immediateFuture
+//            (androidx.media3.session.SessionResult(
+//                androidx.media3.session.SessionResult.RESULT_SUCCESS))
+
+                    ): ListenableFuture<SessionResult> {
+//                        val future = ResolvableFuture.create<SessionResult>()
+//                        future.set(SessionResult(SessionResult.RESULT_SUCCESS))
+//                        return future
+                        return CallbackToFutureAdapter.getFuture { completer ->
+                            completer.set(SessionResult(SessionResult.RESULT_SUCCESS))
+                            "CustomCommandHandled"
+                        }
+                    }
+                }
 
-        override fun onSeekTo(pos: Long) {
-            super.onSeekTo(pos)
-            seekPlayerTo(pos)
+                mediaSession = MediaSession.Builder(context, player)
+                    .setCallback(mediaSessionCallback).build()
+            }
+            return mediaSession!!
         }
     }
 
+    enum class MediaButtonAction {
+        play,
+        pause,
+        playOrPause,
+        next,
+        prev,
+        stop
+    }
+
+//    init {
+//        getMediaSession(context).setCallback(mediaSessionCallback)
+//    }
+
     init {
-        getMediaSessionCompat(context).setCallback(mediaSessionCallback)
+        instance = this
+        getMediaSession(context) // Ensure media session is initialized
     }
 
     private fun getAdjustedKeyCode(keyEvent: KeyEvent): Int {
         val keyCode = keyEvent.keyCode
-        return if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
+        return if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY || keyCode ==
+            KeyEvent.KEYCODE_MEDIA_PAUSE) {
             KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE
         } else keyCode
     }
@@ -81,23 +131,45 @@ class MediaButtonsReceiver(context: Context, private val onAction: (MediaButtonA
         }
     }
 
+    /*
     fun onIntentReceive(intent: Intent?) {
-        if (intent == null) {
-            return
-        }
-        if (intent.action != Intent.ACTION_MEDIA_BUTTON) {
-            return
-        }
+        if (intent == null) return
+        if (intent.action != Intent.ACTION_MEDIA_BUTTON) return
         (intent.extras?.get(Intent.EXTRA_KEY_EVENT) as? KeyEvent)
-                ?.takeIf { it.action == KeyEvent.ACTION_DOWN }
-                ?.let { getAdjustedKeyCode(it) }
-                ?.let { mapAction(it) }
-                ?.let { action ->
-                    handleMediaButton(action)
-                }
+            ?.takeIf { it.action == KeyEvent.ACTION_DOWN }
+            ?.let { getAdjustedKeyCode(it) }
+            ?.let { mapAction(it) }
+            ?.let { action -> handleMediaButton(action) }
+    }
+
 
+     */
+    fun onIntentReceive(intent: Intent?) {
+        if (intent == null) return
+        if (intent.action != Intent.ACTION_MEDIA_BUTTON) return
+
+        // Use getParcelable for type-safe retrieval
+        //@Suppress("DEPRECATION") // Suppress the deprecation warning for the parameter if needed, although getParcelable itself isn't deprecated
+        val keyEvent: KeyEvent? = intent.extras?.getParcelable(Intent.EXTRA_KEY_EVENT, KeyEvent::class.java)
+
+        keyEvent
+            ?.takeIf { it.action == KeyEvent.ACTION_DOWN }
+            ?.let { getAdjustedKeyCode(it) }
+            ?.let { mapAction(it) }
+            ?.let { action -> handleMediaButton(action) }
     }
 
+/*
+    fun onIntentReceive(intent: Intent?) {
+        if (intent == null) return
+        if (intent.action != Intent.ACTION_MEDIA_BUTTON) return
+        val keyEvent = intent.getParcelableExtraCompat<KeyEvent>(Intent.EXTRA_KEY_EVENT)
+        keyEvent?.takeIf { it.action == KeyEvent.ACTION_DOWN }
+            ?.let { getAdjustedKeyCode(it) }
+            ?.let { mapAction(it) }
+            ?.let { action -> handleMediaButton(action) }
+    }
+*/
     private fun seekPlayerTo(pos: Long) {
         this.onNotifSeek(pos)
     }
@@ -105,4 +177,4 @@ class MediaButtonsReceiver(context: Context, private val onAction: (MediaButtonA
     private fun handleMediaButton(action: MediaButtonAction) {
         this.onAction(action)
     }
-}
\ No newline at end of file
+}
diff --git a/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/NotificationManager.kt b/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/NotificationManager.kt
index c271e64..98d511a 100644
--- a/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/NotificationManager.kt
+++ b/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/NotificationManager.kt
@@ -1,54 +1,254 @@
 package com.github.florent37.assets_audio_player.notification
 
+import android.content.ComponentName
 import android.content.Context
 import android.content.Intent
+import android.os.Bundle
+import androidx.core.content.ContextCompat
+import androidx.media3.session.MediaController
+import androidx.media3.session.SessionToken
 import com.github.florent37.assets_audio_player.AssetsAudioPlayerPlugin
+import com.github.florent37.assets_audio_player.MyMediaSessionService // Replace with your service name
+import com.google.common.util.concurrent.ListenableFuture
+import com.google.common.util.concurrent.MoreExecutors // You might need to add this dependency
 
 class NotificationManager(private val context: Context) {
 
     var closed = false
 
+    private var mediaControllerFuture: ListenableFuture<MediaController>? = null
+    private var mediaController: MediaController? = null
+
+    init {
+        // Connect to the MediaSessionService when the NotificationManager is created.
+        // This should be done efficiently, perhaps only when the first player
+        // requests notification display.
+        connectMediaController()
+    }
+
+    private fun connectMediaController() {
+        if (mediaController == null && mediaControllerFuture == null) {
+            // Replace MyMediaSessionService with the actual name of your service class
+            val sessionToken = SessionToken(context, ComponentName(context, MyMediaSessionService::class.java))
+            mediaControllerFuture = MediaController.Builder(context, sessionToken).buildAsync()
+            mediaControllerFuture?.addListener({
+                mediaController = mediaControllerFuture?.get()
+                // Once connected, you can send initial state or commands if needed.
+                // For example, if there was a player active before the plugin was hot-reloaded,
+                // you might want to restore its state.
+            }, MoreExecutors.directExecutor()) // Use a suitable executor, e.g., a background thread pool
+        }
+    }
+
+    private fun releaseMediaController() {
+        mediaControllerFuture?.let { future ->
+            MediaController.releaseFuture(future)
+            mediaControllerFuture = null
+        }
+        mediaController = null
+    }
+
     fun showNotification(playerId: String, audioMetas: AudioMetas, isPlaying: Boolean, notificationSettings: NotificationSettings, stop: Boolean, durationMs: Long) {
-        try {
-            if (closed)
-                return
-            if (stop) {
-                stopNotification()
-            } else {
-                context.startService(Intent(context, NotificationService::class.java).apply {
-                    putExtra(NotificationService.EXTRA_NOTIFICATION_ACTION, NotificationAction.Show(
-                            isPlaying = isPlaying,
-                            audioMetas = audioMetas,
-                            playerId = playerId,
-                            notificationSettings = notificationSettings,
-                            durationMs = durationMs
-                    ))
-                })
-            }
-            AssetsAudioPlayerPlugin.instance?.assetsAudioPlayer?.registerLastPlayerWithNotif(playerId)
-        } catch (t: Throwable) {
-            t.printStackTrace()
+        if (closed) {
+            return
+        }
+
+        // Ensure the MediaSessionService is running.
+        // The MediaSessionService will manage the notification and the MediaSession.
+        val serviceIntent = Intent(context, MyMediaSessionService::class.java)
+        // You might need to pass some initial data to the service here
+        // if it needs it to initialize the session or player.
+        // If this is the first time starting the service for this playback session,
+        // you might include the playerId and initial audioMetas.
+        ContextCompat.startForegroundService(context, serviceIntent)
+
+        // Ensure the MediaController is connected before sending commands
+        connectMediaController()
+
+        if (stop) {
+            // Inform the MediaSessionService to stop playback for this player ID
+            // and potentially hide the notification if no other players are active.
+            // The MediaSessionService would handle the actual stopping of the player
+            // and updating the MediaSession state and notification.
+            mediaController?.sendCustomCommand(Command.COMMAND_STOP_PLAYER, Bundle().apply {
+                putString(Command.EXTRA_PLAYER_ID, playerId)
+            })
+            //stopNotification()
+        } else {
+            // Inform the MediaSessionService about the playback state and metadata update
+            // for the specified player ID.
+            // The MediaSessionService would update the MediaSession and notification accordingly.
+            // You need to make AudioMetas and NotificationSettings Parcelable to pass them in a Bundle.
+            mediaController?.sendCustomCommand(Command.COMMAND_UPDATE_PLAYER_STATE, Bundle().apply {
+                putString(Command.EXTRA_PLAYER_ID, playerId)
+                putBoolean(Command.EXTRA_IS_PLAYING, isPlaying)
+                // putParcelable(Command.EXTRA_AUDIO_METAS, audioMetas) // Requires AudioMetas to be Parcelable
+                // putParcelable(Command.EXTRA_NOTIFICATION_SETTINGS, notificationSettings) // Requires NotificationSettings to be Parcelable
+                putLong(Command.EXTRA_DURATION_MS, durationMs)
+                // You might also need to send the current position if relevant for the notification/MediaSession
+                // putLong(Command.EXTRA_CURRENT_POSITION_MS, currentPositionMs)
+            })
+
+            // Tell the MediaSessionService which player is currently controlling the notification.
+            // This custom command would be received by the MediaSessionService's callback.
+            // The MediaSessionService will then update its internal state to track the active player
+            // and ensure its MediaSession is the primary one managing the notification and handling commands.
+            mediaController?.sendCustomCommand(Command.COMMAND_SET_ACTIVE_PLAYER, Bundle().apply {
+                putString(Command.EXTRA_PLAYER_ID, playerId)
+            })
         }
+
+        // The MediaSessionService will handle registering the active player with the plugin instance
+        // based on the COMMAND_SET_ACTIVE_PLAYER command received via its MediaSession.Callback.
+        // You should remove this line from here as the service is responsible for this.
+        // AssetsAudioPlayerPlugin.instance?.assetsAudioPlayer?.registerLastPlayerWithNotif(playerId)
     }
 
     fun stopNotification() {
-        try {
-            context.startService(Intent(context, NotificationService::class.java).apply {
-                putExtra(NotificationService.EXTRA_NOTIFICATION_ACTION, NotificationAction.Hide(
-                ))
-            })
-        } catch (t: Throwable) {
-            t.printStackTrace()
+        if (closed) {
+            return
         }
+        // Inform the MediaSessionService to hide the notification.
+        // This might be used when all players are stopped or the user dismisses the notification.
+        // The MediaSessionService would then stop itself if there are no active players
+        // or reasons to remain in the foreground.
+        mediaController?.sendCustomCommand(Command.COMMAND_HIDE_NOTIFICATION, null)
     }
 
     fun hideNotificationService(definitively: Boolean = false) {
-        try {
-            //if remainingNotif == 0, stop
-            context.stopService(Intent(context, NotificationService::class.java))
-            closed = definitively
-        } catch (t: Throwable) {
-            t.printStackTrace()
+        if (closed) {
+            return
+        }
+        // This might correspond to completely stopping the MediaSessionService
+        // and releasing all resources.
+        mediaController?.sendCustomCommand(Command.COMMAND_STOP_SERVICE, null)
+        releaseMediaController()
+        closed = definitively
+    }
+
+    // You might need to release the MediaController when the plugin is unregistered.
+    // For example, in the dispose method of your Flutter plugin's Android implementation.
+    fun dispose() {
+        releaseMediaController()
+        closed = true
+    }
+}
+
+// Define custom commands to communicate with the MediaSessionService
+object Command {
+    const val COMMAND_SET_ACTIVE_PLAYER = "set_active_player"
+    const val COMMAND_UPDATE_PLAYER_STATE = "update_player_state"
+    const val COMMAND_STOP_PLAYER = "stop_player" // Command to specifically stop a player via service
+    const val COMMAND_HIDE_NOTIFICATION = "hide_notification"
+    const val COMMAND_STOP_SERVICE = "stop_service"
+
+    const val EXTRA_PLAYER_ID = "player_id"
+    const val EXTRA_IS_PLAYING = "is_playing"
+    const val EXTRA_AUDIO_METAS = "audio_metas"
+    const val EXTRA_NOTIFICATION_SETTINGS = "notification_settings"
+    const val EXTRA_DURATION_MS = "duration_ms"
+    // Add other extras as needed, e.g., current position
+    // const val EXTRA_CURRENT_POSITION_MS = "current_position_ms"
+}
+
+// You will need to make AudioMetas and NotificationSettings Parcelable
+// so they can be passed through Bundles.
+// Example:
+/*
+import android.os.Parcel
+import android.os.Parcelable
+
+data class AudioMetas(
+    val title: String?,
+    val artist: String?,
+    val album: String?,
+    val imageUri: String?, // Or whatever type your image representation is
+    val notificationIcon: String?,
+    val artDownloader: String?
+) : Parcelable {
+    constructor(parcel: Parcel) : this(
+        parcel.readString(),
+        parcel.readString(),
+        parcel.readString(),
+        parcel.readString(),
+        parcel.readString(),
+        parcel.readString()
+    )
+
+    override fun writeToParcel(parcel: Parcel, flags: Int) {
+        parcel.writeString(title)
+        parcel.writeString(artist)
+        parcel.writeString(album)
+        parcel.writeString(imageUri)
+        parcel.writeString(notificationIcon)
+        parcel.writeString(artDownloader)
+    }
+
+    override fun describeContents(): Int {
+        return 0
+    }
+
+    companion object CREATOR : Parcelable.Creator<AudioMetas> {
+        override fun createFromParcel(parcel: Parcel): AudioMetas {
+            return AudioMetas(parcel)
+        }
+
+        override fun newArray(size: Int): Array<AudioMetas?> {
+            return arrayOfNulls(size)
+        }
+    }
+}
+
+data class NotificationSettings(
+    val nextEnabled: Boolean,
+    val prevEnabled: Boolean,
+    val stopEnabled: Boolean,
+    val customStopAction: Boolean,
+    val playPauseEnabled: Boolean,
+    val seekBarEnabled: Boolean,
+    val customPlayPauseAction: Boolean,
+    val customNextAction: Boolean,
+    val customPrevAction: Boolean,
+    val msNotification: Int
+) : Parcelable {
+    constructor(parcel: Parcel) : this(
+        parcel.readByte() != 0.toByte(),
+        parcel.readByte() != 0.toByte(),
+        parcel.readByte() != 0.toByte(),
+        parcel.readByte() != 0.toByte(),
+        parcel.readByte() != 0.toByte(),
+        parcel.readByte() != 0.toByte(),
+        parcel.readByte() != 0.toByte(),
+        parcel.readByte() != 0.toByte(),
+        parcel.readByte() != 0.toByte(),
+        parcel.readInt()
+    )
+
+    override fun writeToParcel(parcel: Parcel, flags: Int) {
+        parcel.writeByte(if (nextEnabled) 1.toByte() else 0.toByte())
+        parcel.writeByte(if (prevEnabled) 1.toByte() else 0.toByte())
+        parcel.writeByte(if (stopEnabled) 1.toByte() else 0.toByte())
+        parcel.writeByte(if (customStopAction) 1.toByte() else 0.toByte())
+        parcel.writeByte(if (playPauseEnabled) 1.toByte() else 0.toByte())
+        parcel.writeByte(if (seekBarEnabled) 1.toByte() else 0.toByte())
+        parcel.writeByte(if (customPlayPauseAction) 1.toByte() else 0.toByte())
+        parcel.writeByte(if (customNextAction) 1.toByte() else 0.toByte())
+        parcel.writeByte(if (customPrevAction) 1.toByte() else 0.toByte())
+        parcel.writeInt(msNotification)
+    }
+
+    override fun describeContents(): Int {
+        return 0
+    }
+
+    companion object CREATOR : Parcelable.Creator<NotificationSettings> {
+        override fun createFromParcel(parcel: Parcel): NotificationSettings {
+            return NotificationSettings(parcel)
+        }
+
+        override fun newArray(size: Int): Array<NotificationSettings?> {
+            return arrayOfNulls(size)
         }
     }
-}
\ No newline at end of file
+}
+*/
diff --git a/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/NotificationService.kt b/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/NotificationService.kt
index fc5b48a..04e7262 100644
--- a/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/NotificationService.kt
+++ b/android/src/main/kotlin/com/github/florent37/assets_audio_player/notification/NotificationService.kt
@@ -8,35 +8,54 @@ import android.content.Context
 import android.content.Intent
 import android.content.pm.PackageManager
 import android.graphics.Bitmap
-import android.media.MediaMetadata
 import android.os.Build
+import android.os.Bundle
 import android.os.IBinder
-/* Eirik 02.04.25: Deprecated Android Support library, replaced by AndroidX equivlants
-import android.support.v4.media.MediaMetadataCompat
-import android.support.v4.media.session.PlaybackStateCompat
-import android.support.v4.media.session.PlaybackStateCompat.ACTION_SEEK_TO
- */
-import androidx.media.MediaMetadataCompat
-import androidx.media.session.PlaybackStateCompat
-import androidx.media.session.PlaybackStateCompat.ACTION_SEEK_TO
+import android.view.KeyEvent
 import androidx.core.app.NotificationCompat
 import androidx.core.app.NotificationManagerCompat
-import androidx.media.session.MediaButtonReceiver
-import com.github.florent37.assets_audio_player.R
-//import com.google.android.exoplayer2.C
 import androidx.media3.common.C
+import androidx.media3.common.MediaMetadata // Media3 MediaMetadata
+import androidx.media3.common.Player // Import Media3 Player
+import androidx.media3.common.util.NotificationUtil // Media3 NotificationUtil for MediaStyle
+import androidx.media3.session.MediaSession // Media3 MediaSession
+import androidx.media3.session.MediaSessionService // Import MediaSessionService
+import androidx.media3.session.SessionCommand
+import androidx.media3.session.SessionResult
+import com.github.florent37.assets_audio_player.R
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.GlobalScope
 import kotlinx.coroutines.launch
 import kotlin.math.abs
+import androidx.media3.session.SessionToken // Import SessionToken
+import androidx.media3.session.MediaController // Import MediaController for communicating with MediaSession
+import com.github.florent37.assets_audio_player.AssetsAudioPlayerPlugin // Assuming access to the plugin instance
+
+// Add the OptIn annotation for unstable Media3 APIs if needed,
+// or mark specific usages with @androidx.media3.common.util.UnstableApi
+// @OptIn(androidx.media3.common.util.UnstableApi::class)
+
+// *** CHANGE 1: Inherit from MediaSessionService ***
+class NotificationService : MediaSessionService() {
 
-class NotificationService : Service() {
+    private var mediaSession: MediaSession? = null // Instance of the Media3 MediaSession
+    // *** CHANGE 2: Track the ID of the currently active player for the notification ***
+    private var activePlayerId: String? = null
+
+    // *** REMOVED: This direct access is no longer suitable.
+    // The service needs a way to get a reference to your Player instance(s) managed by the plugin.
+    // The logic for accessing players will be handled in the custom command processing.
+    /*
+    private val yourPlayerInstance: Player?
+        get() = null // Replace with your actual player access logic
+     */
 
     companion object {
         const val NOTIFICATION_ID = 1
         const val CHANNEL_ID = "assets_audio_player"
         const val MEDIA_SESSION_TAG = "assets_audio_player"
 
+        // Keep existing constants for intents and manifest metadata
         const val EXTRA_PLAYER_ID = "playerId"
         const val EXTRA_NOTIFICATION_ACTION = "notificationAction"
         const val TRACK_ID = "trackID";
@@ -48,171 +67,412 @@ class NotificationService : Service() {
         const val manifestIconNext = "assets.audio.player.notification.icon.next"
         const val manifestIconStop = "assets.audio.player.notification.icon.stop"
 
-        private var stateCompat : PlaybackStateCompat? = null
+        // *** REMOVED: updateNotifMetaData is no longer needed here ***
+        // The MediaSession automatically handles metadata updates based on the connected Player.
+        /*
+        fun updateNotifMetaData(context: Context,
+                                durationMs: Long,
+                                title: String? = null,
+                                artist: String? = null,
+                                album: String? = null
+        ) {
+           // ... (removed logic)
+        }
+        */
+
+    }
 
-        fun timeDiffer(old: PlaybackStateCompat?, new: PlaybackStateCompat, minDifferenceMS: Long) : Boolean {
-            if(old == null){
-                return true
-            }
+    // *** CHANGE 3: Implement onGetSession() ***
+    // This is required by MediaSessionService to provide the MediaSession to clients.
+    override fun onGetSession(controllerInfo: androidx.media3.session.MediaSession.ControllerInfo): MediaSession? {
+        return mediaSession
+    }
 
-            val currentPos = old.position
-            return abs(new.position - currentPos) > minDifferenceMS
+    override fun onCreate() {
+        super.onCreate()
+        createNotificationChannel()
+        // Initialize the MediaSession here. It will be linked to a player later.
+        initializeMediaSession()
+    }
+
+    private fun initializeMediaSession() {
+        // The MediaSession is created here. We don't link a player immediately
+        // because the active player can change. The player will be set on the
+        // MediaSession when a COMMAND_SET_ACTIVE_PLAYER is received.
+        mediaSession = MediaSession.Builder(this, DummyPlayer()) // *** CHANGE 4: Use a DummyPlayer initially ***
+            .setSessionActivity(createContentIntent()) // Optional: Set a PendingIntent to launch an Activity
+            .setCallback(MediaSessionCallback()) // Implement the MediaSession.Callback
+            .build()
+
+        // The MediaSession is now created. The MediaSessionService automatically makes the session active.
+    }
+
+    // *** CHANGE 5: Refactor MediaSession.Callback to handle custom commands and delegate to the active player ***
+    private inner class MediaSessionCallback : MediaSession.Callback {
+
+        // Handle standard Media3 commands (play, pause, seek, skip)
+        // These commands are typically sent from controllers (like the notification or media buttons)
+        // and should be delegated to the currently active player.
+        override fun onPlay(session: MediaSession, controller: androidx.media3.session.MediaSession.ControllerInfo): Int {
+            getActivePlayer()?.play()
+            return SessionResult.RESULT_SUCCESS
         }
 
-        fun updatePosition(context: Context, isPlaying: Boolean, currentPositionMs: Long, speed: Float) {
-            MediaButtonsReceiver.getMediaSessionCompat(context).let { mediaSession ->
-                val state = if (isPlaying) PlaybackStateCompat.STATE_PLAYING else PlaybackStateCompat.STATE_PAUSED
-                val newState = PlaybackStateCompat.Builder()
-                        .setActions(ACTION_SEEK_TO)
-                        .setState(state, currentPositionMs, if (isPlaying) speed else 0f)
-                        .build()
-
-                if(
-                        //pause -> play, play-> pause
-                        stateCompat?.state != newState.state ||
-                        //speed changed
-                        stateCompat?.playbackSpeed != speed ||
-                        //seek
-                        timeDiffer(stateCompat, newState, 2000)
-                ){
-                    stateCompat = newState
-                    mediaSession.setPlaybackState(stateCompat)
-                }
+        override fun onPause(session: MediaSession, controller: androidx.media3.session.MediaSession.ControllerInfo): Int {
+            getActivePlayer()?.pause()
+            return SessionResult.RESULT_SUCCESS
+        }
 
-            }
+        override fun onStop(session: MediaSession, controller: androidx.media3.session.MediaSession.ControllerInfo): Int {
+            getActivePlayer()?.stop()
+            // Consider stopping the service when playback stops for all players
+            // This logic will be handled by the service managing multiple players.
+            return SessionResult.RESULT_SUCCESS
         }
 
+        override fun onSeekTo(session: MediaSession, controller: androidx.media3.session.MediaSession.ControllerInfo, position: Long): Int {
+             getActivePlayer()?.seekTo(position)
+            return SessionResult.RESULT_SUCCESS
+        }
 
-        private fun MediaMetadataCompat.Builder.putStringIfNotNull(key: String, value: String?) : MediaMetadataCompat.Builder {
-            return if(value != null)
-                this.putString(key, value)
-            else
-                this
+        override fun onSkipToNext(session: MediaSession, controller: androidx.media3.session.MediaSession.ControllerInfo): Int {
+            // Delegate next command to your active player
+            // getActivePlayer()?.seekToNext() // Assuming your player has a seekToNext method
+            // Or implement your logic to move to the next track for the active player
+            return SessionResult.RESULT_SUCCESS
         }
 
-        fun updateNotifMetaData(context: Context, display: Boolean,
-                                durationMs: Long,
-                                title: String? = null,
-                                artist: String? = null,
-                                album: String? = null
-        ) {
-            val mediaSession = MediaButtonsReceiver.getMediaSessionCompat(context)
-
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-                val builder = MediaMetadataCompat.Builder()
-                        //for samsung devices https://github.com/florent37/Flutter-AssetsAudioPlayer/issues/205
-                        .putStringIfNotNull(MediaMetadata.METADATA_KEY_TITLE, title)
-                        .putStringIfNotNull(MediaMetadata.METADATA_KEY_ARTIST, artist)
-                        .putStringIfNotNull(MediaMetadata.METADATA_KEY_ALBUM, album)
-
-                if (!display || durationMs == 0L /* livestream */) {
-                    builder.putLong(MediaMetadata.METADATA_KEY_DURATION, C.TIME_UNSET)
-                } else {
-                    builder.putLong(MediaMetadata.METADATA_KEY_DURATION, durationMs)
+        override fun onSkipToPrevious(session: MediaSession, controller: androidx.media3.session.MediaSession.ControllerInfo): Int {
+            // Delegate previous command to your active player
+            // getActivePlayer()?.seekToPrevious() // Assuming your player has a seekToPrevious method
+            // Or implement your logic to move to the previous track for the active player
+            return SessionResult.RESULT_SUCCESS
+        }
+
+        // *** CHANGE 6: Implement onCustomCommand to handle commands from NotificationManager ***
+        override fun onCustomCommand(session: MediaSession,
+                                     controller: androidx.media3.session.MediaSession.ControllerInfo,
+                                     customCommand: SessionCommand, args: Bundle?): SessionResult {
+            when (customCommand.customAction) {
+                Command.COMMAND_SET_ACTIVE_PLAYER -> {
+                    val playerId = args?.getString(Command.EXTRA_PLAYER_ID)
+                    if (playerId != null) {
+                        activePlayerId = playerId
+                        // *** CHANGE 7: Link the active player to the MediaSession ***
+                        // Get the actual Player instance based on playerId and set it on the MediaSession.
+                        // This requires a way to access your player instances from within the service.
+                        // Example (assuming you have a function to get a player by ID):
+                        val playerToLink = getPlayerById(playerId) // You need to implement getPlayerById
+                        if (playerToLink != null) {
+                            session.player = playerToLink
+                            // Update MediaMetadata and PlaybackState immediately if needed
+                            // (though setting the player should handle this automatically)
+                            // updateMediaSessionState(playerToLink) // Optional, might be handled by setting the player
+                        } else {
+                            // Handle error: player not found
+                        }
+
+// *** CHANGE 8: Inform the plugin instance about the active notification player ***
+                        // This replaces the line removed in the previous version of the code.
+                        // The plugin instance needs to know which player is now controlling the notification.
+                        AssetsAudioPlayerPlugin.instance?.onNotificationPlayerChanged(playerId)
+
+                        return SessionResult.RESULT_SUCCESS // Indicate success
+                    }
+                    return SessionResult.RESULT_ERROR_BAD_VALUE // Indicate missing playerId
                 }
 
-                mediaSession.setMetadata(builder.build())
+                Command.COMMAND_UPDATE_PLAYER_STATE -> {
+                    // *** CHANGE 11: Handle updating the state of the active player and notification ***
+                    // This command is sent from the NotificationManager to update the UI/notification.
+                    // We just need to ensure the MediaSession's linked player's state and metadata
+                    // are current. The MediaSession and MediaStyle notification will automatically
+                    // update when the underlying player's state changes.
+                    // You might not need to do anything explicit here if your players
+                    // are correctly updating the linked MediaSession.
+                    // However, if you need to trigger a notification update explicitly,
+                    // you could do it here.
+                    val playerId = args?.getString(Command.EXTRA_PLAYER_ID)
+                    val playerToUpdate = if (playerId == activePlayerId) session.player else getPlayerById(playerId ?: "")
+                    if (playerToUpdate != null) {
+                        // No need to manually update the notification here.
+                        // The MediaSession will observe the player's state.
+                        // Ensure your players are correctly reporting state changes.
+                        // You might consider updating the MediaMetadata on the player
+                        // if it has changed.
+                    }
+                    return SessionResult.RESULT_SUCCESS
+                }
+
+                Command.COMMAND_STOP_PLAYER -> {
+                    // *** CHANGE 12: Handle stopping a specific player ***
+                    val playerId = args?.getString(Command.EXTRA_PLAYER_ID)
+                    if (playerId != null) {
+                        val playerToStop = getPlayerById(playerId) // Get the player by ID
+                        playerToStop?.stop() // Stop the specific player
+                        playerToStop?.release() // Release resources if needed
+
+                        // If the stopped player was the active one, unlink it from the MediaSession
+                        if (playerId == activePlayerId) {
+                            mediaSession?.player = DummyPlayer() // Unlink the player
+                            activePlayerId = null // Clear the active player ID
+                            stopForeground(true) // Stop foreground service and remove notification
+                            stopSelf() // Stop the service if no players are active
+                        }
+                        // You might also need to remove the player from your internal tracking
+                        // in the plugin instance.
+                    }
+                    return SessionResult.RESULT_SUCCESS
+                }
+                Command.COMMAND_HIDE_NOTIFICATION -> {
+                    // *** CHANGE 13: Handle hiding the notification ***
+                    hideNotif()
+                    // You might also want to stop the service here if this command
+                    // implies stopping playback altogether.
+                    // stopSelf() // Consider stopping the service
+                    return SessionResult.RESULT_SUCCESS
+                }
+                Command.COMMAND_STOP_SERVICE -> {
+                    // *** CHANGE 14: Handle stopping the service entirely ***
+                    stopSelf()
+                    return SessionResult.RESULT_SUCCESS
+                }
+                else -> {
+                    // Handle other custom commands if any
+                    return super.onCustomCommand(session, controller, customCommand, args)
+                }
             }
         }
     }
 
-    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
-        if (intent.action == Intent.ACTION_MEDIA_BUTTON) {
-            MediaButtonsReceiver.getMediaSessionCompat(applicationContext).let {
-                MediaButtonReceiver.handleIntent(it, intent)
-            }
+    // *** CHANGE 15: Implement a Player.Listener to observe the active player's state ***
+    private val playerEventListener = object : Player.Listener {
+        override fun onPlaybackStateChanged(playbackState: Int) {
+            // Handle playback state changes (playing, paused, buffered, etc.)
+            // The MediaSession automatically reflects this.
+            // You might add custom logic here if needed, e.g., updating UI in the plugin.
+             when (playbackState) {
+                 Player.STATE_IDLE -> {
+                     // Player is idle, might consider stopping the service/notification
+                     // hideNotif()
+                     // stopSelf() // Consider stopping the service
+                 }
+                 Player.STATE_ENDED -> {
+                     // Playback ended, consider stopping the service/notification
+                      hideNotif()
+                     stopSelf() // Stop the service
+                 }
+                 Player.STATE_BUFFERING -> {
+                     // Buffering
+                 }
+                 Player.STATE_READY -> {
+                     // Ready to play
+                 }
+             }
+        }
+
+        override fun onPlayWhenReadyChanged(playWhenReady: Boolean, reason: Int) {
+            // Handle playWhenReady changes
+            // This reflects whether the player is supposed to play when ready.
         }
+
+        override fun onIsPlayingChanged(isPlaying: Boolean) {
+            // Handle isPlaying changes (true when actually playing audio)
+            // This is a good place to update the notification if needed, though
+            // the MediaSession linked to the player should handle this automatically.
+            // You can still call displayNotification here if you need more control
+            // over the notification appearance based on isPlaying state.
+             if (isPlaying) {
+                 // Player is playing, ensure the service is in the foreground
+                 // The MediaSessionService should manage this, but you can reinforce it.
+                 // startForeground(NOTIFICATION_ID, buildNotification(...)) // Rebuild and start foreground if needed
+             } else {
+                 // Player is paused or stopped, update the notification
+                 // The MediaSessionService should manage this.
+                 // If you need to stop the foreground service when paused:
+                 // if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+                 //     stopForeground(STOP_FOREGROUND_DETACH) // Keep notification but stop foreground
+                 // } else {
+                 //    stopForeground(false) // Keep notification but stop foreground
+                 // }
+             }
+        }
+
+        override fun onMediaMetadataChanged(mediaMetadata: MediaMetadata) {
+            // Handle metadata changes
+            // The MediaSession automatically reflects this, updating the notification.
+            // You might update UI in the plugin based on new metadata.
+        }
+
+         override fun onPlaybackParametersChanged(playbackParameters: PlaybackParameters) {
+             // Handle playback speed or pitch changes
+         }
+
+         override fun onPlayerError(error: PlaybackException) {
+             // Handle player errors
+             // You might want to stop playback, update the notification, or log the error.
+         }
+
+        // Implement other relevant Player.Listener methods as needed.
+    }
+
+
+    // *** CHANGE 16: Remove the manual onStartCommand processing of notification actions ***
+    // The MediaSession and its Callback will handle media button intents.
+    // You will still receive Intents to start the service, but the playback
+    // control commands will go through the MediaSession.
+    /*
+    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
+        // Continue to handle your existing notification actions
         when (val notificationAction = intent.getSerializableExtra(EXTRA_NOTIFICATION_ACTION)) {
             is NotificationAction.Show -> {
-                displayNotification(notificationAction)
+                // The displayNotification logic needs to be updated to work with MediaSession
+                // displayNotification(notificationAction)
             }
             is NotificationAction.Hide -> {
                 hideNotif()
             }
         }
+        // The MediaSession will now handle media button intents automatically.
+        // You might not need to process them directly here anymore.
+
         return START_NOT_STICKY
     }
+    */
+
+    // *** CHANGE 17: Implement getActivePlayer() to retrieve the currently active Player instance ***
+    // This is a placeholder. You need to implement the actual logic to get the Player
+    // instance based on the activePlayerId. This will likely involve accessing the
+    // player instances managed by your AssetsAudioPlayerPlugin.
+    private fun getActivePlayer(): Player? {
+        // TODO: Implement actual logic to get the active Player from the plugin
+        // Example: return AssetsAudioPlayerPlugin.instance?.getPlayer(activePlayerId)
+        return null // Replace with your implementation
+    }
 
+    // *** CHANGE 18: Implement getPlayerById() to retrieve a Player instance by ID ***
+    // This is a placeholder. You need to implement the actual logic to retrieve
+    // the correct Player instance from your plugin's management based on the provided ID.
+    private fun getPlayerById(playerId: String): Player? {
+        // Access the static instance of the plugin
+        val pluginInstance = AssetsAudioPlayerPlugin.instance
+        // Access the AssetsAudioPlayer instance from the plugin
+        val assetsAudioPlayer = pluginInstance?.assetsAudioPlayer
+        // Access the players map from the AssetsAudioPlayer instance and get the player by ID
+        return assetsAudioPlayer?.getPlayers()?.get(playerId)
+    }
+
+/*
     private fun createReturnIntent(forAction: String, forPlayer: String, audioMetas: AudioMetas): Intent {
         return Intent(this, NotificationActionReceiver::class.java)
                 .setAction(forAction)
                 .putExtra(EXTRA_PLAYER_ID, forPlayer)
                 .putExtra(TRACK_ID, audioMetas.trackID)
     }
-
-    private fun displayNotification(action: NotificationAction.Show) {
-        GlobalScope.launch(Dispatchers.Main) {
+*/
+// *** CHANGE 19: Update displayNotification to build a notification compatible with MediaSession ***
+    // You still need to build the notification here, but it will be linked to the MediaSession.
+    // Media3's MediaStyleNotificationHelper is useful, or you can use NotificationCompat.MediaStyle.
+    private fun displayNotification(notificationAction: NotificationAction.Show) {
+        val notificationBuilder = NotificationCompat.Builder(this, CHANNEL_ID).apply {
+            // Set notification icon
+            setSmallIcon(getResourceId(manifestIcon))
+
+            // Set content title and text from notificationAction
+            setContentTitle(notificationAction.title)
+            setContentText(notificationAction.artist)
+            setSubText(notificationAction.album)
+
+            // Set large icon if available (handle bitmap loading asynchronously if needed)
+            notificationAction.imageUri?.let { uri ->
+                GlobalScope.launch(Dispatchers.IO) {
+                    val bitmap = try {
+                        // Assuming a helper function to load bitmap from URI
+                        BitmapLoader.loadBitmapFromUri(this@NotificationService, uri)
+                    } catch (e: Exception) {
+                        e.printStackTrace()
+                        null
+                    }
+                    bitmap?.let {
+                        // Update the notification with the bitmap
+                        notificationBuilder.setLargeIcon(it)
+                        NotificationManagerCompat.from(this@NotificationService)
+                            .notify(NOTIFICATION_ID, notificationBuilder.build())
+                    }
+                }
+/*
             val image = ImageDownloader.loadBitmap(context = applicationContext, imageMetas = action.audioMetas.image)
             if(image != null){
-                displayNotification(action, image) //display without image for now
+                displayNotification(action, image) //display with image
                 return@launch
             }
             val imageOnLoadError = ImageDownloader.loadBitmap(context = applicationContext, imageMetas = action.audioMetas.imageOnLoadError)
             if(imageOnLoadError != null){
-                displayNotification(action, imageOnLoadError) //display without image for now
+                displayNotification(action, imageOnLoadError) //display with error image
                 return@launch
             }
 
             val imageFromManifest = ImageDownloader.loadHolderBitmapFromManifest(context = applicationContext)
             if(imageFromManifest != null){
-                displayNotification(action, imageFromManifest) //display without image for now
+                displayNotification(action, imageFromManifest) //display with manifest image
                 return@launch
             }
 
             displayNotification(action, null) //display without image
+ */
+
         }
     }
-
-
-    private fun getSmallIcon(context: Context): Int {
-        //return getCustomIconOrDefault(context, manifestIcon, null, R.drawable.exo_icon_circular_play)
-        //return getCustomIconOrDefault(context, manifestIcon, R.drawable.notification_icon)
+/*
+    // Icon retrieval methods remain largely the same, assuming your drawable resources exist
+    private fun getSmallIcon(context: Context, resourceName: String?): Int {
+        // Keep your existing logic for getting the small icon
         return getCustomIconOrDefault(context, manifestIcon, context.resources.getIdentifier(
             "exo_icon_small", "drawable", "androidx.media3.ui"), null)
     }
 
     private fun getPlayIcon(context: Context, resourceName: String?): Int {
-        //return getCustomIconOrDefault(context, manifestIconPlay, resourceName, R.drawable.exo_icon_play)
+        // Keep your existing logic for getting the play icon
         return getCustomIconOrDefault(context, manifestIconPlay, context.resources.getIdentifier(
             "exo_icon_play", "drawable", "androidx.media3.ui"), resourceName)
     }
 
     private fun getPauseIcon(context: Context, resourceName: String?): Int {
-        //return getCustomIconOrDefault(context, manifestIconPause, resourceName, R.drawable.exo_icon_pause)
+        // Keep your existing logic for getting the pause icon
         return getCustomIconOrDefault(context, manifestIconPause, context.resources.getIdentifier(
             "exo_icon_pause", "drawable", "androidx.media3.ui"), resourceName)
     }
 
     private fun getNextIcon(context: Context, resourceName: String?): Int {
-        //return getCustomIconOrDefault(context, manifestIconNext, resourceName, R.drawable.exo_icon_next)
+        // Keep your existing logic for getting the next icon
         return getCustomIconOrDefault(context, manifestIconNext, context.resources.getIdentifier(
             "exo_icon_next", "drawable", "androidx.media3.ui"), resourceName)
     }
 
     private fun getPrevIcon(context: Context, resourceName: String?): Int {
-        //return getCustomIconOrDefault(context, manifestIconPrev, resourceName, R.drawable.exo_icon_previous)
+        // Keep your existing logic for getting the previous icon
         return getCustomIconOrDefault(context, manifestIconPrev, context.resources.getIdentifier(
             "exo_icon_previous", "drawable", "androidx.media3.ui"), resourceName)
     }
 
     private fun getStopIcon(context: Context, resourceName: String?): Int {
-        //return getCustomIconOrDefault(context, manifestIconStop, resourceName, R.drawable.exo_icon_stop)
+        // Keep your existing logic for getting the stop icon
         return getCustomIconOrDefault(context, manifestIconStop, context.resources.getIdentifier(
             "exo_icon_stop", "drawable", "androidx.media3.ui"), resourceName)
     }
-
-    //private fun getCustomIconOrDefault(context: Context, manifestName: String, resourceName: String?, defaultIcon: Int): Int {
+*/
+            // *** CHANGE 20: Use MediaStyle for playback controls and metadata display ***
+            // Link the notification to the MediaSession
+            setStyle(
+                androidx.media3.session.MediaStyleNotificationHelper.MediaStyle(mediaSession!!)
+                // Or using NotificationCompat.MediaStyle directly:
+                // NotificationCompat.MediaStyle().setMediaSession(mediaSession!!.sessionCompatToken) // If using Support Library MediaSession
+                    .setShowActionsInCompactView(0, 1, 2) // Indices of actions to show in compact view (e.g., Prev, Play/Pause, Next)
+            )
+/*
     private fun getCustomIconOrDefault(context: Context, manifestName: String, defaultIcon: Int, resourceName: String? = null): Int {
         try {
             // by resource name
-            //val customIconFromName = getResourceID(resourceName)
-/*            val customIconFromName = resourceName?.let {
-                //getResourceID(it)
-                getResourceID(context, it)
-            }
-            if (customIconFromName != null) {
-                return customIconFromName
-            }*/
             if (!resourceName.isNullOrEmpty()){
                 val customIconFromName = context.resources.getIdentifier(resourceName, "drawable", context.packageName)
 
@@ -234,158 +494,353 @@ class NotificationService : Service() {
         //if customIconFromName is null or customIconFromManifest is null
         return defaultIcon
     }
+*/
+
+            // *** CHANGE 21: Add actions for playback control (linked to MediaSession) ***
+            // Media3 automatically handles play/pause, next, previous actions if your Player supports them.
+            // You might still need custom actions for stop or other commands.
+
+            // Example of adding a custom Stop action:
+            addAction(
+                getIconResourceId(manifestIconStop),
+                "Stop",
+                getStopPendingIntent() // You need to create this PendingIntent
+            )
+            // Media3 will automatically add default play/pause, next, previous actions
+            // based on the Player capabilities linked to the MediaSession.
+
+            // Set click intent for the notification
+            setContentIntent(createContentIntent())
+
+            // Allow the notification to be dismissed
+            setOngoing(false)
+
+            // Set visibility for lock screen controls
+            setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
+
+            // *** CHANGE 22: Set MediaMetadata on the MediaSession's Player ***
+            // The notification automatically picks up metadata from the linked Player.
+            // Update the Player's metadata when it changes.
+            val mediaMetadata = MediaMetadata.Builder()
+                .setTitle(notificationAction.title)
+                .setArtist(notificationAction.artist)
+                .setAlbumTitle(notificationAction.album)
+                .setArtworkUri(notificationAction.imageUri)
+                .setDurationMs(notificationAction.durationMs ?: C.TIME_UNSET)
+                .build()
+            getActivePlayer()?.setMediaMetadata(mediaMetadata)
+
+            // *** CHANGE 23: Set PlaybackState on the MediaSession's Player ***
+            // The notification automatically picks up playback state from the linked Player.
+            // Ensure your Player correctly reports its state.
+            // The Player.Listener onPlaybackStateChanged and onIsPlayingChanged will help with this.
 
-/* Eirik 20.03.25: Not needed anymore?
-    //private fun getResourceID(iconName: String?): Int? {
-    private fun getResourceID(context: Context, iconName: String): Int? {
-        //return iconName?.let { name ->
-        //    resources.getIdentifier(name, "drawable", applicationContext.packageName)
-        return if(iconName.isNotEmpty()) {
-            context.resources.getIdentifier(iconName, "drawable", context.packageName)
-        } else {
-            null
         }
+
+        // Start the service in the foreground with the notification
+        // *** CHANGE 24: Use startForeground() with the MediaSessionService's API ***
+        // MediaSessionService has a built-in way to handle foreground service.
+        // You call setForegroundNotification() and the service manages the rest.
+        // You might still need to call startService() initially to start the service.
+        setNotification(NOTIFICATION_ID, notificationBuilder.build())
+
+        // If you are calling this from a place where the service might not be running foreground
+        // you might need to explicitly start it:
+         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+             startForeground(NOTIFICATION_ID, notificationBuilder.build(), Notification.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK)
+         } else {
+             startForeground(NOTIFICATION_ID, notificationBuilder.build())
+         }
+
+        // *** REMOVED: Manual notification display ***
+        /*
+        NotificationManagerCompat.from(this)
+            .notify(NOTIFICATION_ID, notificationBuilder.build())
+        */
     }
-*/
-    private fun displayNotification(action: NotificationAction.Show, bitmap: Bitmap?) {
-        createNotificationChannel()
-        val mediaSession = MediaButtonsReceiver.getMediaSessionCompat(applicationContext)
 
-        val notificationSettings = action.notificationSettings
+    // *** CHANGE 25: Implement updateMediaSessionState() to explicitly update MediaSession ***
+    // While setting the player usually triggers updates, you might need this
+    // after linking a player or when other relevant state changes occur.
+    private fun updateMediaSessionState(player: Player) {
+        // The MediaSession will automatically observe the Player.
+        // Explicitly updating metadata or playback state on the Player
+        // will reflect in the MediaSession and subsequently the notification.
+        // For example, if you need to update the position:
+        // mediaSession?.setPlaybackState(
+        //     PlaybackStateCompat.Builder()
+        //         .setState(player.playbackState, player.currentPosition, player.playbackSpeed)
+        //         .setActions(...) // Define available actions
+        //         .build()
+        // )
+        // Or update metadata if it has changed outside of a Player event:
+        // mediaSession?.setMetadata(
+        //     MediaMetadataCompat.Builder()
+        //         .setTitle(...)
+        //         .setArtist(...)
+        //         .build()
+        // )
+    }
 
-        updateNotifMetaData(
-                context = applicationContext,
-                display = notificationSettings.seekBarEnabled,
-                title = action.audioMetas.title,
-                artist = action.audioMetas.artist,
-                album = action.audioMetas.album,
-                durationMs = action.durationMs
+
+    // *** CHANGE 26: Create a PendingIntent to launch your main Activity ***
+    // This is typically what happens when the user clicks on the notification.
+    private fun createContentIntent(): PendingIntent {
+        //val openAppIntent = packageManager.getLaunchIntentForPackage(packageName)
+        val intent = packageManager.getLaunchIntentForPackage(packageName)
+        //return if (openAppIntent != null) {
+        //    PendingIntent.getActivity(
+        return PendingIntent.getActivity(
+            this,
+            0,
+            //openAppIntent,
+            intent,
+            PendingIntent.FLAG_IMMUTABLE // Use FLAG_IMMUTABLE for security
         )
+    }
 
-        val toggleIntent = createReturnIntent(forAction = NotificationAction.ACTION_TOGGLE, forPlayer = action.playerId, audioMetas = action.audioMetas)
-                .putExtra(EXTRA_NOTIFICATION_ACTION, action.copyWith(
-                        isPlaying = !action.isPlaying
-                ))
-        val pendingToggleIntent = PendingIntent.getBroadcast(this, 0, toggleIntent, PendingIntent.FLAG_UPDATE_CURRENT)
-        MediaButtonReceiver.handleIntent(mediaSession, toggleIntent)
-
-        val context = this
-
-        val notification = NotificationCompat.Builder(this, CHANNEL_ID)
-                //prev
-                .apply {
-                    if (notificationSettings.prevEnabled) {
-                        addAction(getPrevIcon(context, action.notificationSettings.previousIcon), "prev",
-                                PendingIntent.getBroadcast(context, 0, createReturnIntent(forAction = NotificationAction.ACTION_PREV, forPlayer = action.playerId, audioMetas = action.audioMetas), PendingIntent.FLAG_UPDATE_CURRENT)
-                        )
-                    }
-                }
-                //play/pause
-                .apply {
-                    if (notificationSettings.playPauseEnabled) {
-                        addAction(
-                                if (action.isPlaying) getPauseIcon(context, action.notificationSettings.pauseIcon) else getPlayIcon(context, action.notificationSettings.playIcon),
-                                if (action.isPlaying) "pause" else "play",
-                                pendingToggleIntent
-                        )
-                    }
-                }
-                //next
-                .apply {
-                    if (notificationSettings.nextEnabled) {
-                        addAction(getNextIcon(context, action.notificationSettings.nextIcon), "next", PendingIntent.getBroadcast(context, 0,
-                                createReturnIntent(forAction = NotificationAction.ACTION_NEXT, forPlayer = action.playerId, audioMetas = action.audioMetas), PendingIntent.FLAG_UPDATE_CURRENT)
-                        )
-                    }
-                }
-                //stop
-                .apply {
-                    if (notificationSettings.stopEnabled) {
-                        addAction(getStopIcon(context, action.notificationSettings.stopIcon), "stop", PendingIntent.getBroadcast(context, 0,
-                                createReturnIntent(forAction = NotificationAction.ACTION_STOP, forPlayer = action.playerId, audioMetas = action.audioMetas), PendingIntent.FLAG_UPDATE_CURRENT)
-                        )
-                    }
-                }
-                .setStyle(androidx.media.app.NotificationCompat.MediaStyle()
-                        .also {
-                            when (notificationSettings.numberEnabled()) {
-                                1 -> it.setShowActionsInCompactView(0)
-                                2 -> it.setShowActionsInCompactView(0, 1)
-                                3 -> it.setShowActionsInCompactView(0, 1, 2)
-                                4 -> it.setShowActionsInCompactView(0, 1, 2, 3)
-                                else -> it.setShowActionsInCompactView()
-                            }
-                        }
-                        .setShowCancelButton(true)
-                        .setMediaSession(mediaSession.sessionToken)
-                )
-                .setSmallIcon(getSmallIcon(context))
-                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
-                .setPriority(NotificationCompat.PRIORITY_MAX)
-                .setContentTitle(action.audioMetas.title)
-                .setContentText(action.audioMetas.artist)
-                .setOnlyAlertOnce(true)
-                .also {
-                    if (!action.audioMetas.album.isNullOrEmpty()) {
-                        it.setSubText(action.audioMetas.album)
-                    }
-                }
-                .setContentIntent(PendingIntent.getBroadcast(this, 0,
-                        createReturnIntent(forAction = NotificationAction.ACTION_SELECT, forPlayer = action.playerId, audioMetas = action.audioMetas), PendingIntent.FLAG_CANCEL_CURRENT))
-                .also {
-                    if (bitmap != null) {
-                        it.setLargeIcon(bitmap)
-                    }
-                }
-                .setShowWhen(false)
-                .build()
+    // *** CHANGE 27: Create PendingIntents for custom actions (e.g., Stop) ***
+    private fun getStopPendingIntent(): PendingIntent {
+        val intent = Intent(this, NotificationService::class.java).apply {
+            action = Command.COMMAND_STOP_SERVICE // Or a specific stop player command
+            // You might include the activePlayerId here if stopping a specific player
+            putExtra(Command.EXTRA_PLAYER_ID, activePlayerId)
+        }
+        return PendingIntent.getService(
+            this,
+            0,
+            intent,
+            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
+        )
+    }
+
+        //val notification = notificationBuilder.build()
+
+    // Utility function to get resource ID from string
+    private fun getResourceId(name: String): Int {
+        return try {
+            resources.getIdentifier(name, "drawable", packageName)
+        } catch (e: Exception) {
+            e.printStackTrace()
+            0
+        }
+    }
+
+/*
         startForeground(NOTIFICATION_ID, notification)
 
+        // The stopForeground logic might need adjustment based on how you manage playback lifecycle
+        // with the Media3 Player. You might stop the service when the player is idle or stopped.
+        // This specific check might still be valid depending on your desired behavior.
         //fix for https://github.com/florent37/Flutter-AssetsAudioPlayer/issues/139
-        if (!action.isPlaying && Build.VERSION.SDK_INT >= 24) {
-           stopForeground(2)
+        if (!action.isPlaying && Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) { // Using Build.VERSION_CODES.N for stopForeground(flags)
+           stopForeground(STOP_FOREGROUND_DETACH or STOP_FOREGROUND_REMOVE) // Using flags for modern Android
+        } else if (action.isPlaying && Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            // Keep the service in the foreground when playing
+            startForeground(NOTIFICATION_ID, notification)
+        } else if (!action.isPlaying && Build.VERSION.SDK_INT < Build.VERSION_CODES.N) {
+             // For older versions, stop the foreground service without flags
+            stopForeground(true) // This version is deprecated but used for older APIs
         }
+    }
+ */
 
+    // Utility function to get drawable resource ID for icons
+    private fun getIconResourceId(name: String): Int {
+        return try {
+            resources.getIdentifier(name, "drawable", packageName)
+        } catch (e: Exception) {
+            e.printStackTrace()
+            0
+        }
     }
 
+/*
+    // Helper function to determine which action indices to show in the compact view
+    private fun getCompactViewActionIndices(notificationSettings: NotificationSettings): IntArray {
+        val indices = mutableListOf<Int>()
+        var currentIndex = 0
+
+        if (notificationSettings.prevEnabled) {
+            // If previous is enabled, it's the first action added
+            indices.add(currentIndex++)
+        }
+        if (notificationSettings.playPauseEnabled) {
+            // Play/Pause is the next action
+            indices.add(currentIndex++)
+        }
+        if (notificationSettings.nextEnabled) {
+            // Next is the next action
+            indices.add(currentIndex++)
+        }
+         if (notificationSettings.stopEnabled) {
+             // Stop is the last action
+             indices.add(currentIndex++)
+         }
+
+        return indices.toIntArray()
+    }
+*/
+
     private fun createNotificationChannel() {
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-            val serviceChannel = NotificationChannel(
-                    CHANNEL_ID,
-                    "Foreground Service Channel",
-                    android.app.NotificationManager.IMPORTANCE_LOW
+            val channel = NotificationChannel(
+                CHANNEL_ID,
+                "Assets Audio Player", // User-visible name
+                NotificationManagerCompat.IMPORTANCE_LOW // Low importance to minimize disruption
             ).apply {
-                description = "assets_audio_player"
-                setShowBadge(false)
-                lockscreenVisibility = Notification.VISIBILITY_PUBLIC
+                description = "Notification channel for Assets Audio Player"
             }
-
-            NotificationManagerCompat.from(applicationContext).createNotificationChannel(
-                    serviceChannel
-            )
+            val notificationManager: NotificationManagerCompat = NotificationManagerCompat.from(this)
+            notificationManager.createNotificationChannel(channel)
         }
     }
 
+    // *** CHANGE 28: Implement hideNotif() to remove the notification ***
     private fun hideNotif() {
-        NotificationManagerCompat.from(applicationContext).cancel(NOTIFICATION_ID)
-        stopForeground(true)
-        stopSelf()
+        NotificationManagerCompat.from(this).cancel(NOTIFICATION_ID)
     }
 
-    override fun onTaskRemoved(rootIntent: Intent) {
-        hideNotif()
+    // *** CHANGE 29: Implement onDestroy() to release the MediaSession ***
+    override fun onDestroy() {
+        mediaSession?.run {
+            player.removeListener(playerEventListener) // Remove the listener
+            release()
+            mediaSession = null
+        }
+        super.onDestroy()
     }
 
-    override fun onCreate() {
-        super.onCreate()
+// *** CHANGE 30: Implement a DummyPlayer for initial MediaSession creation ***
+    // This player doesn't actually play audio but satisfies the MediaSession's requirement
+    // for a Player instance when initially creating the session before a real player
+    // is linked.
+    private class DummyPlayer : Player {
+        override fun getPlaybackState(): Int = STATE_IDLE
+        override fun getPlayWhenReady(): Boolean = false
+        override fun getCurrentPosition(): Long = 0
+        override fun getDuration(): Long = C.TIME_UNSET
+        override fun getBufferedPosition(): Long = 0
+        override fun getBufferedPercentage(): Int = 0
+        override fun getTotalBufferedDuration(): Long = 0
+        override fun isPlayingAd(): Boolean = false
+        override fun isLoading(): Boolean = false
+        override fun getCurrentMediaItemIndex(): Int = 0
+        override fun getCurrentMediaItem(): androidx.media3.common.MediaItem? = null
+        override fun getPlaybackSpeed(): Float = 1.0f
+        override fun getPlayerError(): PlaybackException? = null
+        override fun getVolume(): Float = 1.0f
+        override fun getAudioSessionId(): Int = C.AUDIO_SESSION_ID_UNSET
+        override fun getMediaMetadata(): MediaMetadata = MediaMetadata.EMPTY
+        override fun getPlaylistMetadata(): MediaMetadata = MediaMetadata.EMPTY
+
+        // Listener management (dummy implementation)
+        private val listeners = mutableSetOf<Player.Listener>()
+        override fun addListener(listener: Player.Listener) { listeners.add(listener) }
+        override fun removeListener(listener: Player.Listener) { listeners.remove(listener) }
+        override fun clearVideoEffects() {}
+        override fun setVideoEffects(videoEffects: List<androidx.media3.common.Effect>) {}
+        override fun clearAuxEffectInfo() {}
+        override fun setAuxEffectInfo(auxEffectInfo: androidx.media3.common.audio.AuxEffectInfo) {}
+        override fun createMessage(target: androidx.media3.common.util.MediaPeriodQueueNavigator): androidx.media3.common.util.ExoPlaybackException? {
+             return null // Not implemented
+        }
+        override fun setWakeMode(wakeMode: Int) {}
+        override fun setHandleAudioBecomingNoisy(handleAudioBecomingNoisy: Boolean) {}
+        override fun setPriorityTaskManager(priorityTaskManager: androidx.media3.common.util.PriorityTaskManager?) {}
+        override fun setSkipSilenceEnabled(skipSilenceEnabled: Boolean) {}
+        override fun getSkipSilenceEnabled(): Boolean { return false }
+
+        // Playback control methods (dummy implementations)
+        override fun prepare() {}
+        override fun play() {}
+        override fun pause() {}
+        override fun stop() {}
+        override fun release() {}
+        override fun seekToDefaultPosition() {}
+        override fun seekToDefaultPosition(mediaItemIndex: Int) {}
+        override fun seekTo(positionMs: Long) {}
+        override fun seekTo(mediaItemIndex: Int, positionMs: Long) {}
+        override fun setPlayWhenReady(playWhenReady: Boolean) {}
+        override fun setRepeatMode(repeatMode: Int) {}
+        override fun getRepeatMode(): Int = Player.REPEAT_MODE_OFF
+        override fun setShuffleModeEnabled(shuffleModeEnabled: Boolean) {}
+        override fun getShuffleModeEnabled(): Boolean = false
+        override fun setPlaybackParameters(playbackParameters: PlaybackParameters) {}
+        override fun setMediaItems(mediaItems: List<androidx.media3.common.MediaItem>) {}
+        override fun addMediaItems(mediaItems: List<androidx.media3.common.MediaItem>) {}
+        override fun removeMediaItems(fromIndex: Int, toIndex: Int) {}
+        override fun moveMediaItems(fromIndex: Int, toIndex: Int, newIndex: Int) {}
+        override fun setMediaItem(mediaItem: androidx.media3.common.MediaItem) {}
+        override fun addMediaItem(mediaItem: androidx.media3.common.MediaItem) {}
+        override fun setVolume(volume: Float) {}
+        override fun getDeviceVolume(): Int = 0
+        override fun isDeviceMuted(): Boolean = true
+        override fun setDeviceVolume(volume: Int) {}
+        override fun increaseDeviceVolume() {}
+        override fun decreaseDeviceVolume() {}
+        override fun setDeviceMuted(muted: Boolean) {}
+        override fun seekBack() {}
+        override fun seekForward() {}
+        override fun setPlaylistMetadata(playlistMetadata: MediaMetadata) {}
+        override fun setMediaMetadata(mediaMetadata: MediaMetadata) {}
+        override fun getApplicationRepeatMode(): Int = REPEAT_MODE_OFF
+        override fun setApplicationRepeatMode(applicationRepeatMode: Int) {}
+        override fun getCurrentLiveConfiguration(): androidx.media3.common.LiveConfiguration? = null
+        override fun isPlaying(): Boolean = false // Dummy always reports not playing
+        override fun getActionForMask(mask: Long): Int = 0 // Dummy implementation
+        override fun isCommandAvailable(command: @Player.Command Int): Boolean = false // Dummy implementation
+        override fun canAdvertiseSession(): Boolean = false // Dummy implementation
+
+        // You might need to override other methods from the Player interface
+        // depending on what methods your MediaSession callback uses or expects
+        // the Player to support. For a dummy player, minimal implementation is usually sufficient.
     }
-
-    override fun onBind(intent: Intent?): IBinder? {
-        return null
+}
+
+// Helper object for custom commands
+object Command {
+    const val COMMAND_SET_ACTIVE_PLAYER = "SET_ACTIVE_PLAYER"
+    const val COMMAND_UPDATE_PLAYER_STATE = "UPDATE_PLAYER_STATE"
+    const val COMMAND_STOP_PLAYER = "STOP_PLAYER"
+    const val COMMAND_HIDE_NOTIFICATION = "HIDE_NOTIFICATION"
+    const val COMMAND_STOP_SERVICE = "STOP_SERVICE"
+
+    // Extra for playerId
+    const val EXTRA_PLAYER_ID = "playerId"
+}
+
+// Helper class for loading bitmaps (replace with your actual implementation)
+object BitmapLoader {
+    suspend fun loadBitmapFromUri(context: Context, uri: String): Bitmap? {
+        // Implement your bitmap loading logic here
+        // This could involve using Coil, Glide, or manually loading from a URI
+        return null // Placeholder
+    }
+}
+
+// Data class to hold notification action information (replace with your actual class)
+data class NotificationAction(
+    val title: String?,
+    val artist: String?,
+    val album: String?,
+    val imageUri: String?,
+    val durationMs: Long?
+) : java.io.Serializable // Make it Serializable if you pass it via Intent Extras
+
+// Assuming your plugin has a static instance and methods to access players
+// Replace with your actual plugin structure
+class AssetsAudioPlayerPlugin {
+    companion object {
+        var instance: AssetsAudioPlayerPlugin? = null
     }
 
-    override fun onDestroy() {
-        super.onDestroy()
+    fun getPlayer(playerId: String): Player? {
+        // Implement logic to retrieve the Player instance by ID
+        return null // Placeholder
     }
 
-}
\ No newline at end of file
+    fun onNotificationPlayerChanged(playerId: String?) {
+        // Implement logic to handle the active notification player change in your plugin
+    }
+}
diff --git a/android/src/main/kotlin/com/github/florent37/assets_audio_player/playerimplem/PlayerImplemExoPlayer.kt b/android/src/main/kotlin/com/github/florent37/assets_audio_player/playerimplem/PlayerImplemExoPlayer.kt
index bd72ce9..b73da42 100644
--- a/android/src/main/kotlin/com/github/florent37/assets_audio_player/playerimplem/PlayerImplemExoPlayer.kt
+++ b/android/src/main/kotlin/com/github/florent37/assets_audio_player/playerimplem/PlayerImplemExoPlayer.kt
@@ -5,25 +5,10 @@ import android.net.Uri
 import android.os.Build
 import android.util.Log
 import androidx.annotation.RequiresApi
+import androidx.core.net.toUri
 import com.github.florent37.assets_audio_player.AssetAudioPlayerThrowable
 import com.github.florent37.assets_audio_player.AssetsAudioPlayerPlugin
 import com.github.florent37.assets_audio_player.Player
-/* Eirik 20.03.25: Old libraries, replaced my androidx.media3
-import com.google.android.exoplayer2.*
-import com.google.android.exoplayer2.C.AUDIO_SESSION_ID_UNSET
-import com.google.android.exoplayer2.Player.REPEAT_MODE_ALL
-import com.google.android.exoplayer2.Player.REPEAT_MODE_OFF
-import com.google.android.exoplayer2.audio.AudioListener
-import com.google.android.exoplayer2.drm.*
-import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory
-import com.google.android.exoplayer2.extractor.ts.AdtsExtractor
-import com.google.android.exoplayer2.source.MediaSource
-import com.google.android.exoplayer2.source.ProgressiveMediaSource
-import com.google.android.exoplayer2.source.dash.DashMediaSource
-import com.google.android.exoplayer2.source.hls.HlsMediaSource
-import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource
-import com.google.android.exoplayer2.upstream.*
- */
 //Eirik 20.03.25: The new androidx.media3 libraries, specified those to use instead of ".*"
 import androidx.media3.common.C
 import androidx.media3.common.MediaItem
@@ -36,6 +21,7 @@ import androidx.media3.datasource.DefaultDataSourceFactory
 import androidx.media3.datasource.DefaultHttpDataSource
 import androidx.media3.datasource.HttpDataSource
 import androidx.media3.exoplayer.ExoPlayer
+import androidx.media3.exoplayer.ExoPlayer.Builder
 import androidx.media3.exoplayer.DefaultLoadControl
 import androidx.media3.exoplayer.ExoPlaybackException
 import androidx.media3.exoplayer.SimpleExoPlayer
@@ -66,7 +52,6 @@ class IncompatibleException(val audioType: String, val type: PlayerImplemTesterE
 
 class PlayerImplemTesterExoPlayer(private val type: Type) : PlayerImplemTester {
 
-
     enum class Type {
         Default,
         HLS,
@@ -74,13 +59,13 @@ class PlayerImplemTesterExoPlayer(private val type: Type) : PlayerImplemTester {
         SmoothStreaming
     }
 
-
     override suspend fun open(configuration: PlayerFinderConfiguration) : PlayerFinder.PlayerWithDuration {
         if(AssetsAudioPlayerPlugin.displayLogs) {
             Log.d("PlayerImplem", "trying to open with exoplayer($type)")
         }
         //some type are only for web
-        if(configuration.audioType != Player.AUDIO_TYPE_LIVESTREAM && configuration.audioType != Player.AUDIO_TYPE_LIVESTREAM){
+        //if(configuration.audioType != Player.AUDIO_TYPE_LIVESTREAM && configuration.audioType != Player.AUDIO_TYPE_LIVESTREAM){
+        if(configuration.audioType != Player.AUDIO_TYPE_NETWORK && configuration.audioType != Player.AUDIO_TYPE_LIVESTREAM){
             if(type == Type.HLS || type == Type.DASH || type == Type.SmoothStreaming) {
                 throw IncompatibleException(configuration.audioType, type)
             }
@@ -101,7 +86,7 @@ class PlayerImplemTesterExoPlayer(private val type: Type) : PlayerImplemTester {
         )
 
         try {
-            val durationMS = mediaPlayer?.open(
+            val durationMS = mediaPlayer.open( // Call open on the PlayerImplemExoPlayer instance
                     context = configuration.context,
                     assetAudioPath = configuration.assetAudioPath,
                     audioType = configuration.audioType,
@@ -111,14 +96,14 @@ class PlayerImplemTesterExoPlayer(private val type: Type) : PlayerImplemTester {
                     drmConfiguration = configuration.drmConfiguration
             )
             return PlayerFinder.PlayerWithDuration(
-                    player = mediaPlayer!!,
-                    duration = durationMS!!
+                    player = mediaPlayer, // Return the PlayerImplemExoPlayer instance
+                    duration = durationMS
             )
         } catch (t: Throwable) {
             if(AssetsAudioPlayerPlugin.displayLogs) {
                 Log.d("PlayerImplem", "failed to open with exoplayer($type)")
             }
-            mediaPlayer?.release()
+            mediaPlayer.release() // Call release on the PlayerImplemExoPlayer instance
             throw  t
         }
     }
@@ -135,31 +120,42 @@ class PlayerImplemExoPlayer(
         onError = onError
 ) {
 
-    private var mediaPlayer: ExoPlayer? = null
+    // Make the ExoPlayer instance public
+    var exoPlayerInstance: ExoPlayer? = null
+        private set // Allow assignment only within this class
+    //private var mediaPlayer: ExoPlayer? = null
 
     override var loopSingleAudio: Boolean
-        get() = mediaPlayer?.repeatMode == REPEAT_MODE_ALL
+        //get() = mediaPlayer?.repeatMode == REPEAT_MODE_ALL
+        get() = exoPlayerInstance?.repeatMode == REPEAT_MODE_ALL
         set(value) {
-            mediaPlayer?.repeatMode = if (value) REPEAT_MODE_ALL else REPEAT_MODE_OFF
+            //mediaPlayer?.repeatMode = if (value) REPEAT_MODE_ALL else REPEAT_MODE_OFF
+            exoPlayerInstance?.repeatMode = if (value) REPEAT_MODE_ALL else REPEAT_MODE_OFF
         }
 
     override val isPlaying: Boolean
-        get() = mediaPlayer?.isPlaying ?: false
+        //get() = mediaPlayer?.isPlaying ?: false
+        get() = exoPlayerInstance?.isPlaying ?: false
     override val currentPositionMs: Long
-        get() = mediaPlayer?.currentPosition ?: 0
+        //get() = mediaPlayer?.currentPosition ?: 0
+        get() = exoPlayerInstance?.currentPosition ?: 0
 
     override fun stop() {
-        mediaPlayer?.stop()
+        //mediaPlayer?.stop()
+        exoPlayerInstance?.stop()
     }
 
     override fun play() {
-        mediaPlayer?.playWhenReady = true
+        //mediaPlayer?.playWhenReady = true
+        exoPlayerInstance?.playWhenReady = true
     }
 
     override fun pause() {
-        mediaPlayer?.playWhenReady = false
+        //mediaPlayer?.playWhenReady = false
+        exoPlayerInstance?.playWhenReady = false
     }
 
+    @UnstableApi
     private fun getDataSource(context: Context,
                       flutterAssets: FlutterPlugin.FlutterAssets,
                       assetAudioPath: String?,
@@ -169,14 +165,28 @@ class PlayerImplemExoPlayer(
                       drmConfiguration: Map<*, *>?
     ): MediaSource {
         try {
-            mediaPlayer?.stop()
+            // Use exoPlayerInstance here as well
+            //mediaPlayer?.stop()
+            exoPlayerInstance?.stop()
             if (audioType == Player.AUDIO_TYPE_NETWORK || audioType == Player.AUDIO_TYPE_LIVESTREAM) {
                 val uri = Uri.parse(assetAudioPath)
                 val userAgent = "assets_audio_player"
 
                 val factory = DataSource.Factory {
                     val allowCrossProtocol = true
-                    val dataSource = DefaultHttpDataSource(userAgent, DefaultHttpDataSource.DEFAULT_CONNECT_TIMEOUT_MILLIS, DefaultHttpDataSource.DEFAULT_READ_TIMEOUT_MILLIS, allowCrossProtocol, null)
+
+                    // Use DefaultHttpDataSource.Factory (Builder) instead of direct constructor
+                    //val dataSource = DefaultHttpDataSource(userAgent, DefaultHttpDataSource.DEFAULT_CONNECT_TIMEOUT_MILLIS, DefaultHttpDataSource.DEFAULT_READ_TIMEOUT_MILLIS, allowCrossProtocol, null)
+
+                    val dataSourceFactory = DefaultHttpDataSource.Factory()
+                        .setUserAgent(userAgent)
+                        .setAllowCrossProtocolRedirects(allowCrossProtocol)
+                        // You might need to set connect/read timeouts on the factory if needed
+                        // .setConnectTimeoutMs(DefaultHttpDataSource.DEFAULT_CONNECT_TIMEOUT_MILLIS)
+                        // .setReadTimeoutMs(DefaultHttpDataSource.DEFAULT_READ_TIMEOUT_MILLIS)
+
+                    // Add headers using the setRequestProperty method on the created DataSource
+                    val dataSource = dataSourceFactory.createDataSource()
                     networkHeaders?.forEach {
                         it.key?.let { key ->
                             it.value?.let { value ->
@@ -184,7 +194,7 @@ class PlayerImplemExoPlayer(
                             }
                         }
                     }
-                    dataSource;
+                    dataSource
                 }
 
                 return when(type){
@@ -199,18 +209,17 @@ class PlayerImplemExoPlayer(
                 val factory = ProgressiveMediaSource
                         .Factory(DefaultDataSourceFactory(context, "assets_audio_player"), DefaultExtractorsFactory())
 
-
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
                     val key = drmConfiguration?.get("clearKey")?.toString()
 
                     if (key != null) {
                         val sessionManager: DrmSessionManager =
                             DefaultDrmSessionManager.Builder().setUuidAndExoMediaDrmProvider(
+                            //C.CLEARKEY_UUID, FrameworkMediaDrm.DEFAULT_PROVIDER).build(LocalMediaDrmCallback(key.toByteArray()))
                             C.CLEARKEY_UUID, FrameworkMediaDrm.DEFAULT_PROVIDER).build(LocalMediaDrmCallback(key.toByteArray()))
                         //factory.setDrmSessionManager(sessionManager)
                         factory.setDrmSessionManagerProvider { sessionManager }
                     }
-
                 }
 
                 //return factory.createMediaSource(Uri.fromFile(File(assetAudioPath)))
@@ -223,7 +232,9 @@ class PlayerImplemExoPlayer(
                     flutterAssets.getAssetFilePathByName(p, assetAudioPackage)
                 }
                 val assetDataSource = AssetDataSource(context)
-                assetDataSource.open(DataSpec(Uri.fromFile(File(path))))
+                val fileUri = "file://$path".toUri()
+                assetDataSource.open(DataSpec(fileUri))
+                //assetDataSource.open(DataSpec(Uri.fromFile(File(path))))
 
                 val factory = DataSource.Factory { assetDataSource }
                 return ProgressiveMediaSource
@@ -235,7 +246,9 @@ class PlayerImplemExoPlayer(
         }
     }
 
-    private fun SimpleExoPlayer.Builder.incrementBufferSize(audioType: String): SimpleExoPlayer.Builder {
+    //private fun SimpleExoPlayer.Builder.incrementBufferSize(audioType: String): SimpleExoPlayer.Builder {
+    @UnstableApi
+    private fun ExoPlayer.Builder.incrementBufferSize(audioType: String): ExoPlayer.Builder {
         if (audioType == Player.AUDIO_TYPE_NETWORK || audioType == Player.AUDIO_TYPE_LIVESTREAM) {
             /* Instantiate a DefaultLoadControl.Builder. */
             val loadControlBuilder = DefaultLoadControl.Builder()
@@ -274,6 +287,7 @@ class PlayerImplemExoPlayer(
         }
     }
 
+    @UnstableApi
     override suspend fun open(
             context: Context,
             flutterAssets: FlutterPlugin.FlutterAssets,
@@ -286,9 +300,15 @@ class PlayerImplemExoPlayer(
         var onThisMediaReady = false
 
         try {
-            mediaPlayer = SimpleExoPlayer.Builder(context)
-                    .incrementBufferSize(audioType)
-                    .build()
+            // Use the public exoPlayerInstance property
+            //exoPlayerInstance = SimpleExoPlayer.Builder(context)
+            exoPlayerInstance = ExoPlayer.Builder(context)
+                .incrementBufferSize(audioType)
+                .build()
+
+            //mediaPlayer = SimpleExoPlayer.Builder(context)
+            //        .incrementBufferSize(audioType)
+            //        .build()
 
             val mediaSource = getDataSource(
                     context = context,
@@ -302,10 +322,10 @@ class PlayerImplemExoPlayer(
 
             var lastState: Int? = null
 
-            //this.mediaPlayer?.addListener(object : com.google.android.exoplayer2.Player.EventListener {
-            this.mediaPlayer?.addListener(object : androidx.media3.common.Player.Listener {
+            // Use the public exoPlayerInstance property for adding listeners
+            //this.mediaPlayer?.addListener(object : androidx.media3.common.Player.Listener {
+            this.exoPlayerInstance?.addListener(object : androidx.media3.common.Player.Listener {
 
-                //override fun onPlayerError(error: ExoPlaybackException) {
                 override fun onPlayerError(error: androidx.media3.common.PlaybackException) {
                     val errorMapped = mapError(error)
                     if (!onThisMediaReady) {
@@ -315,7 +335,6 @@ class PlayerImplemExoPlayer(
                     }
                 }
 
-                //override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {
                 override fun onPlaybackStateChanged(playbackState: Int) {
                     if (lastState != playbackState) {
                         when (playbackState) {
@@ -335,7 +354,8 @@ class PlayerImplemExoPlayer(
                                     if (audioType == Player.AUDIO_TYPE_LIVESTREAM) {
                                         continuation.resume(0) //no duration for livestream
                                     } else {
-                                        val duration = mediaPlayer?.duration ?: 0
+                                        //val duration = mediaPlayer?.duration ?: 0
+                                        val duration = exoPlayerInstance?.duration ?: 0 // Use exoPlayerInstance
                                         val totalDurationMs = (duration.toLong())
 
                                         continuation.resume(totalDurationMs)
@@ -350,7 +370,9 @@ class PlayerImplemExoPlayer(
                 }
             })
 
-            mediaPlayer?.prepare(mediaSource)
+            // Use the public exoPlayerInstance property for preparing
+            //mediaPlayer?.prepare(mediaSource)
+            exoPlayerInstance?.prepare(mediaSource)
         } catch (error: Throwable) {
             if (!onThisMediaReady) {
                 continuation.resumeWithException(error)
@@ -362,65 +384,60 @@ class PlayerImplemExoPlayer(
     }
 
     override fun release() {
-        mediaPlayer?.release()
+        //mediaPlayer?.release()
+        exoPlayerInstance?.release()
+        exoPlayerInstance = null // Set to null after releasing
     }
 
     override fun seekTo(to: Long) {
-        mediaPlayer?.seekTo(to)
+        //mediaPlayer?.seekTo(to)
+        exoPlayerInstance?.seekTo(to) // Use exoPlayerInstance
     }
 
     override fun setVolume(volume: Float) {
-        mediaPlayer?.audioComponent?.volume = volume
+        //mediaPlayer?.audioComponent?.volume = volume
+        exoPlayerInstance?.volume = volume // Use exoPlayerInstance
     }
 
     override fun setPlaySpeed(playSpeed: Float) {
-        val params: PlaybackParameters? = mediaPlayer?.getPlaybackParameters()
+        //val params: PlaybackParameters? = mediaPlayer?.getPlaybackParameters()
+        val params: PlaybackParameters? = exoPlayerInstance?.getPlaybackParameters() // Use exoPlayerInstance
         if (params != null) {
-            mediaPlayer?.setPlaybackParameters(PlaybackParameters(playSpeed, params.pitch))
+            //mediaPlayer?.setPlaybackParameters(PlaybackParameters(playSpeed, params.pitch))
+            exoPlayerInstance?.setPlaybackParameters(PlaybackParameters(playSpeed, params.pitch)) // Use exoPlayerInstance
         }
     }
 
     override fun setPitch(pitch: Float) {
-        val params: PlaybackParameters? = mediaPlayer?.getPlaybackParameters()
+        //val params: PlaybackParameters? = mediaPlayer?.getPlaybackParameters()
+        val params: PlaybackParameters? = exoPlayerInstance?.getPlaybackParameters() // Use exoPlayerInstance
         if (params != null) {
-            mediaPlayer?.setPlaybackParameters(PlaybackParameters(params.speed, pitch))
-        }
-    }
-
-    /* Eirik 20.03.25: Old implementation old type listener (com.google.android.exoplayer2 package)
-    override fun getSessionId(listener: (Int) -> Unit) {
-        val id = mediaPlayer?.audioComponent?.audioSessionId?.takeIf { it != AUDIO_SESSION_ID_UNSET }
-        if (id != null) {
-            listener(id)
-        } else {
-            val listener = object : AudioListener {
-                override fun onAudioSessionIdChanged(audioSessionId: Int) {
-                    listener(audioSessionId)
-                    mediaPlayer?.audioComponent?.removeAudioListener(this)
-                }
-            }
-            mediaPlayer?.audioComponent?.addAudioListener(listener)
+            //mediaPlayer?.setPlaybackParameters(PlaybackParameters(params.speed, pitch))
+            exoPlayerInstance?.setPlaybackParameters(PlaybackParameters(params.speed, pitch)) // Use exoPlayerInstance
         }
-        //return
     }
 
-     */
     //Eirik 20.03.25: Replacement using androidx.media3
+    @UnstableApi
     override fun getSessionId(listener: (Int) -> Unit) {
-        val id = mediaPlayer?.audioSessionId?.takeIf { it != AUDIO_SESSION_ID_UNSET }
+        //val id = mediaPlayer?.audioSessionId?.takeIf { it != AUDIO_SESSION_ID_UNSET }
+        val id = exoPlayerInstance?.audioSessionId?.takeIf { it != AUDIO_SESSION_ID_UNSET } // Use exoPlayerInstance
         if (id != null) {
             listener(id)
         } else {
             val playerListener = object : androidx.media3.common.Player.Listener {
                 override fun onAudioAttributesChanged(audioAttributes: androidx.media3.common.AudioAttributes) {
-                    val id = mediaPlayer?.audioSessionId
+                    //val id = mediaPlayer?.audioSessionId
+                    val id = exoPlayerInstance?.audioSessionId // Use exoPlayerInstance
                     if (id != null && id != AUDIO_SESSION_ID_UNSET) {
                         listener(id)
-                        mediaPlayer?.removeListener(this)
+                        //mediaPlayer?.removeListener(this)
+                        exoPlayerInstance?.removeListener(this) // Use exoPlayerInstance
                     }
                 }
             }
-            mediaPlayer?.addListener(playerListener)
+            //mediaPlayer?.addListener(playerListener)
+            exoPlayerInstance?.addListener(playerListener) // Use exoPlayerInstance
         }
     }
 }
\ No newline at end of file
diff --git a/assets_audio_player_web/.gitignore b/assets_audio_player_web/.gitignore
deleted file mode 100644
index e9dc58d..0000000
--- a/assets_audio_player_web/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-.DS_Store
-.dart_tool/
-
-.packages
-.pub/
-
-build/
diff --git a/assets_audio_player_web/.metadata b/assets_audio_player_web/.metadata
deleted file mode 100644
index ec5d410..0000000
--- a/assets_audio_player_web/.metadata
+++ /dev/null
@@ -1,10 +0,0 @@
-# This file tracks properties of this Flutter project.
-# Used by Flutter tool to assess capabilities and perform upgrades etc.
-#
-# This file should be version controlled and should not be manually edited.
-
-version:
-  revision: b8bd09db210d2c6299555643af8db4b8ff3e8d92
-  channel: master
-
-project_type: plugin
diff --git a/assets_audio_player_web/CHANGELOG.md b/assets_audio_player_web/CHANGELOG.md
deleted file mode 100644
index 7da7f59..0000000
--- a/assets_audio_player_web/CHANGELOG.md
+++ /dev/null
@@ -1,409 +0,0 @@
-## 3.1.1
-
-- fix startup crash issue for some Android devices.
-
-## 3.1.0
-
-- revert back changes
-
-## 3.0.9
-
-- fix notification package naming and build issue
-
-## 3.0.8
-
-- fix warnings
-
-## 3.0.7
-
-- Update dependencies and fix notification issue
-
-## 3.0.6
-
-- Update kotling version and fix minor issues
-
-## 3.0.5
-
-- Breaking change, with Flutter 3.0 removed null aware for WidgetsBinding
-
-## 3.0.4+5
-
-- Fixed null aware
-
-## 3.0.4+4
-
-- Fix issues and update exoplayer
-
-## 3.0.4+3
-
-- Fix warnings and abstract issue
-
-## 3.0.4+2
-
-- Fix flutter 3.0 issues
-
-## 3.0.4+1
-
-- Fix andorid 12 issues and update exoplayer and gradles
-
-## 3.0.4
-
-- Fix web open player issue
-- update example app Android 12 compatable
-
-## 3.0.3+9
-
-- Fix mimType issue mp3 files from urls without extension #630
-- Fix web Null issue
-
-## 3.0.3+8
-
-- Fix android 12 / api 31 issue.
-- Fix macOs build issue
-- Fix web assets issue for Web
-
-## 3.0.3+7
-
-- Fix android 12 / api 31 issue.
-- Fix macOs build issue
-- Fix web assets issue for Web
-## 3.0.3+6
-* Added DRM supports
-* Fix playSpeed for WEB.
-## 3.0.3+5
-* Added pitch controller
-## 3.0.3+4
-* Updated dependencies 
-* Fix duplicate class issue
-* Fix: assetsAudioPlayer.open playSpeed is not work
-## 3.0.3+3
-* fix duration issue
-## 3.0.3+2
-* update build number
-## 3.0.3+1
-* fixed no function for stopForeground
-## 3.0.3
-
-* Fix notification issue
-## 3.0.2
-
-* Fix version issue
-## 3.0.1
-
-* Fix web player
-## 3.0.0
-
-* Fix some issues
-* Migrate to null safety
-
-## 2.0.15
-
-* update android 30 and fixed local assets issue
-* should fix android alarm manager issue
-
-## 2.0.14
-
-* update packages
-## 2.0.13+9
-
-* fix opening multiple audio player.
-## 2.0.13+8
-
-* fix opening multiple audio player.
-## 2.0.13+7
-
-* fix version conflicts
-## 2.0.13+6
-
-* fix android crash issue
-## 2.0.13+5
-
-* fix opened multiple instance for android problem.
-## 2.0.13+2
-
-* fixed some issues on ios
-* fix crash issue on android
-
-## 2.0.13+1
-
-* fixed some innues on macos/ios
-
-## 2.0.12
-
-* Fixed AudioType.network networkHeaders
-* Improve documentation
-* CustomPrevIcon fixed
-
-## 2.0.9+2
-
-* Renamed PhoneCallStrategy to AudioFocusStrategy
-* Allow on android to resume native players after focus lost
-
-## 2.0.8+5
-
-* Added Android HeadPhoneStrategy
-* Fix local path file uri (android)
-* Added open multiple calls protection
-* Open uri content on androids
-
-## 2.0.6+7
-
-* Cache now use `http` instead of `dio`
-* Added live tag on notification for LiveStream play (ios)
-* Added audio session id (android only)
-
-## 2.0.5+7
-
-* Added custom error handling (beta)
-* Dispose is now a future
-* Fixed playlist insert / replace
-
-## 2.0.5
-
-* Added Cache management (beta), with Audio.network(url, cached: true)
-
-## 2.0.4+2
-
-* Added HLS, Dash, SmoothStream support on Android
-* Added `laylist.replaceAt` method
-
-## 2.0.3+6
-
-* ExoPlayer network now set `allowCrossProtocolRedirect=true` by default
-* Fixed notification hide on livestream pause (android)
-* Added custom icons for android from drawable names
-* Fixed notification texts on Samsung devices
-
-## 2.0.3+1
-
-* Added custom notification icons for Android (in AndroidManifest.xml)
-* Fixed `seek` and `seekBy` not working on the web
-* `PlayList.startIndex` is now mutable
-* Stop player then call `play` reopen it at `playlist.startIndex`
-* Increased buffer size on android/exoplayer
-* Added keepLoopMode on prev/next
-
-## 2.0.2
-
-* Breaking change : `loop` boolean now enumerate 3 values : `none`, `single` and `playlist`
-
-## 2.0.1+9
-
-* Added `.showNotification = true/false` to hide dynamically displayed notification
-* Added custom action on notif click(android)
-* Added `isBuffering` to `RealtimePlayingInfos`
-* Added `AssetsAudioPlayerGroup` (beta)
-* Added Headers in `Audio.network` & `Audio.liveStream`
-
-## 2.0.1
-
-* Added `.playerState` (play/pause/stop)
-* Stop now ping finish listeners
-
-## 2.0.0+6
-
-* Added MacOS support
-* Fixed gapeless loop (single audio)
-* Fixed audio file notification
-
-## 1.7.0
-
-* Fixed bluetooth on android on some devices
-* Fallback to android native MediaPlayer if exoplayer can't read the file
-* Added `audio.updateMetas` to update notification content after creation
-* Android Seekbar notification is now optional
-* Android usable notification Seekbar
-* Added stop custom notification action
-
-## 1.6.3
-
-* Custom notification icon (android)
-* Custom notification actions
-* Fixed notification close on android
-* Fixed android auto-focus
-* Added playInBackground mode
-* Added shuffle
-
-## 1.6.1
-
-* Playlist is now mutable, we can add audios after creation
-* renamed `ReadingPlaylist get playlist` to `ReadingPlaylist get readingPlaylist`
-* added `Playlist get playlist`
-
-## 1.6.0+4
-
-* Fixed playlist issue on android
-* Fixed issue on bluetooth android play/pause
-* Fixed PlayerBuilder currentPosition
-* Added extra map into audio
-
-## 1.6.0
-
-* Added some checks on swift code
-* Fixed totalDuration or liveStream
-* Fixed ios notifications
-* Added bluetooth headset actions (play/pause/next/prev/stop)
-
-## 1.5.0
-
-* Added `Audio.liveStream(url)`
-* Fixed notification image from assets on android
-* Fixed android notification actions on playlist
-* Added `AudioWidget`
-
-## 1.4.7
-
-* added `package` on assets audios (& notif images)
-* all methods return Future
-* open can throw an exception if the url is not found
-
-## 1.4.6+1
-
-* fixed android notifications actions
-* refactored package, added `src/` and `package` keyword
-* added player_builders
-
-## 1.4.5
-
-* fixed implementation of local file play on iOS
-
-## 1.4.4
-
-* Added notifications on android
-
-## 1.4+3+6
-
-* Beta fix for audio focus
-
-## 1.4+3+5 
-
-* Beta implementation of local file play on iOS
-
-## 1.4.3+4
-
-* Moved to last flutter version `>=1.12.13+hotfix.6`
-* Implemented new android `FlutterPlugin` 
-* Stop all players while getting a phone call
-* Added `playspeed` as optional parameter on on open()
-
-## 1.4.2+1
-
-* Moved to android ExoPlayer
-* Added `playSpeed` (beta)
-* Added `forwardRewind` (beta)
-* Added `seekBy`
-
-## 1.4.0+1
-
-* Bump gradle versions : `wrapper`=(5.4.1-all) `build:gradle`=(3.5.3)
-
-## 1.4.0
-
-* Added `respectSilentMode` as open optional argument
-* Added `showNotification` on iOS to map with MPNowPlayingInfoCenter (default: false)
-* Added `metas` on audios (title, artist, ...) for notifications
-* Use new plugin build format for iOS
-
-## 1.3.9
-
-* Empty constructor now create a new player
-* Added factory AssetsAudioPlayer.withId()
-* Added `playAndForget` witch create, open, play & dispose the player on finish
-* Added AssetsAudioPlayer.allPlayers() witch returns a map of all players
-* Reworked the android player
-
-## 1.3.8+1
-
-* Added `seek` as optional parameter on `open` method
-
-## 1.3.8
-
-* Fully rebased the web support on html.AudioElement (instead of howler)
-* Fully rebases the ios support on AvPlayer (instead of AvAudioPlayer)
-* Added support for network audios with `.open(Audio.network(url))` on Android/ios/web
-
-## 1.3.7+1
-
-* Added `RealtimePlayingInfos` stream
-
-## 1.3.6+1
-
-* Added volume as optional parameter on open()
-
-## 1.3.6
-
-* Extracted web support to assets_audio_player_web: 1.3.6
-
-## 1.3.5+1
-
-* Volume does not reset anymore on looping audios
-
-## 1.3.4
-
-* Fixed player on Android
-
-## 1.3.3
-
-* Fixed build on Android & iOS
-
-## 1.3.2
-
-- Rewritten the web support, using now https://github.com/florent37/flutter_web_howl
-
-## 1.3.1+2
-
-* Upgraded RxDart dependency
-* fixed lint issues
-* lowerCamelCase AssetsAudioPlayer volumes consts 
-
-## 1.3.1
-
-* Fixed build on iOS
-
-## 1.3.0 
-
-* Added web support, works only on debug mode
-
-## 1.2.8
-
-* Added constructors 
-- AssetsAudioPlayer.newPlayer
-- AssetsAudioPlayer(id: "PLAYER_ID") 
-
-to create new players and play multiples songs in parallel
-
-the default constructor AssetsAudioPlayer() still works as usual
-
-## 1.2.7
-
-* Added "volume" property (listen/set)
-
-## 1.2.6
-
-* Added an "autoPlay" optional attribute to open methods
-
-## 1.2.5
-
-* Compatible with Swift 5
-
-## 1.2.4
-
-* Added playlist
-
-## 1.2.3
-
-* Added playlist (beta)
-
-## 1.2.1
-
-* Added looping setter/getter
-
-## 1.2.0
-
-* Upgraded RxDart to 0.23.1
-* Fixed assets playing on iOS
-* Fixed playing location on Android
-
-## 0.0.1
-
-* initial release.
diff --git a/assets_audio_player_web/LICENSE b/assets_audio_player_web/LICENSE
deleted file mode 100644
index d9e3d01..0000000
--- a/assets_audio_player_web/LICENSE
+++ /dev/null
@@ -1,201 +0,0 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright 2019 Florent37
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
diff --git a/assets_audio_player_web/README.md b/assets_audio_player_web/README.md
deleted file mode 100644
index a55c6f8..0000000
--- a/assets_audio_player_web/README.md
+++ /dev/null
@@ -1,1022 +0,0 @@
-# 🎧 assets_audio_player  🔊
-
-[![pub package](https://img.shields.io/pub/v/assets_audio_player.svg)](
-https://pub.dartlang.org/packages/assets_audio_player)
-<a href="https://github.com/Solido/awesome-flutter">
-   <img alt="Awesome Flutter" src="https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat" />
-</a>
-<img src="https://img.shields.io/badge/platform-android%20%7C%20ios%20%7C%20macos%20%7C%20web%20-%23989898" />
-
-
-[![Codemagic build status](https://api.codemagic.io/apps/5ed8002fe1907b001c67db52/5ed8002fe1907b001c67db51/status_badge.svg)](https://codemagic.io/apps/5ed8002fe1907b001c67db52/5ed8002fe1907b001c67db51/latest_build)
-[![CodeFactor](https://www.codefactor.io/repository/github/florent37/flutter-assetsaudioplayer/badge)](https://www.codefactor.io/repository/github/florent37/flutter-assetsaudioplayer)
-
-Play music/audio stored in assets files (simultaneously) directly from Flutter (android / ios / web / macos). 
-
-You can also use play audio files from **network** using their url, **radios/livestream** and **local files**
-
-**Notification can be displayed on Android & iOS, and bluetooth actions are handled**
-
-```yaml
-flutter:
-  assets:
-    - assets/audios/
-```
-
-```Dart
-AssetsAudioPlayer.newPlayer().open(
-    Audio("assets/audios/song1.mp3"),
-    autoPlay: true,
-    showNotification: true,
-);
-```
-
-[![sample1](./medias/sample1.png)](https://github.com/florent37/Flutter-AssetsAudioPlayer)
-[![sample1](./medias/sample2.png)](https://github.com/florent37/Flutter-AssetsAudioPlayer)
-
-# 📥 Import
-
-```yaml
-dependencies:
-  assets_audio_player: ^2.0.13
-  
-or
-
-assets_audio_player:
-git:
-url: https://github.com/florent37/Flutter-AssetsAudioPlayer.git
-ref: master
-
-ref can be latest commit id. 
-```
-
-**Works with `flutter: ">=1.12.13+hotfix.6 <2.0.0"`, be sure to upgrade your sdk**
-
-You like the package ? buy me a kofi :)
-
-<a href='https://ko-fi.com/A160LCC' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://az743702.vo.msecnd.net/cdn/kofi1.png?v=0' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a>
-
-<table>
-    <thead>
-        <tr>
-            <th>Audio Source</th>
-            <th>Android</th>
-            <th>iOS</th>
-            <th>Web</th>
-            <th>MacOS</th>
-        </tr>
-    </thead>
-    <tbody>
-        <tr>
-          <td>🗄️ Asset file (asset path)</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>🌐 Network file (url)</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>📁 Local file (path)</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>📻 Network LiveStream / radio (url) <br/> (<b>Default, HLS, Dash, SmoothStream</b>)</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-    </tbody>
-</table>
-
-<table>
-    <thead>
-        <tr>
-            <th>Feature</th>
-            <th>Android</th>
-            <th>iOS</th>
-            <th>Web</th>
-            <th>MacOS</th>
-        </tr>
-    </thead>
-    <tbody>
-        <tr>
-          <td>🎶 Multiple players</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>💽 Open Playlist</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>💬System notification</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>🚫</td>
-          <td>🚫</td>
-        </tr>
-        <tr>
-          <td>🎧 Bluetooth actions</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>🚫</td>
-          <td>🚫</td>
-        </tr>
-        <tr>
-          <td>🔕 Respect System silent mode</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>🚫</td>
-          <td>🚫</td>
-        </tr>
-        <tr>
-          <td>📞 Pause on phone call</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>🚫</td>
-          <td>🚫</td>
-        </tr>
-    </tbody>
-</table>
-
-<table>
-    <thead>
-        <tr>
-            <th>Commands</th>
-            <th>Android</th>
-            <th>iOS</th>
-            <th>Web</th>
-            <th>MacOS</th>
-        </tr>
-    </thead>
-    <tbody>
-        <tr>
-          <td>▶ Play</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>⏸ Pause</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>⏹ Stop</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>⏩ Seek(position)</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>⏪⏩ SeekBy(position)</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>⏩ Forward(speed)</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>⏪ Rewind(speed)</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>⏭ Next</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-           <td>⏮ Prev</td>
-           <td>✅</td>
-           <td>✅</td>
-           <td>✅</td>
-           <td>✅</td>
-        </tr>
-    </tbody>
-</table>
-
-<table>
-    <thead>
-        <tr>
-            <th>Widgets</th>
-            <th>Android</th>
-            <th>iOS</th>
-            <th>Web</th>
-            <th>MacOS</th>
-        </tr>
-    </thead>
-    <tbody>
-        <tr>
-           <td>🐦 Audio Widget</td>
-           <td>✅</td>
-           <td>✅</td>
-           <td>✅</td>
-           <td>✅</td>
-        </tr>
-        <tr>
-            <td>🐦 Widget Builders</td>
-            <td>✅</td>
-            <td>✅</td>
-            <td>✅</td>
-            <td>✅</td>
-        </tr>
-        <tr>
-             <td>🐦 AudioPlayer Builders Extension</td>
-             <td>✅</td>
-             <td>✅</td>
-             <td>✅</td>
-             <td>✅</td>
-         </tr>
-    </tbody>
-</table>
-
-<table>
-    <thead>
-        <tr>
-            <th>Properties</th>
-            <th>Android</th>
-            <th>iOS</th>
-            <th>Web</th>
-            <th>MacOS</th>
-        </tr>
-    </thead>
-    <tbody>
-        <tr>
-          <td>🔁 Loop</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>🔀 Shuffle</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>🔊 get/set Volume</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>⏩ get/set Play Speed</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-    </tbody>
-</table>
-
-<table>
-    <thead>
-        <tr>
-            <th>Listeners</th>
-            <th>Android</th>
-            <th>iOS</th>
-            <th>Web</th>
-            <th>MacOS</th>
-        </tr>
-    </thead>
-    <tbody>
-        <tr>
-          <td>🦻 Listener onReady(completeDuration)</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-           <td>🦻 Listener currentPosition</td>
-           <td>✅</td>
-           <td>✅</td>
-           <td>✅</td>
-           <td>✅</td>
-        </tr>
-        <tr>
-          <td>🦻 Listener finished</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-           <td>🦻 Listener buffering</td>
-           <td>✅</td>
-           <td>✅</td>
-           <td>✅</td>
-           <td>✅</td>
-        </tr>
-        <tr>
-          <td>🦻 Listener volume</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-        <tr>
-          <td>🦻Listener Play Speed</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-          <td>✅</td>
-        </tr>
-    </tbody>
-</table>
-
-# 📁 Import assets files
-
-No needed to copy songs to a media cache, with assets_audio_player you can open them directly from the assets. 
-
-1. Create an audio directory in your assets (not necessary named "audios")
-2. Declare it inside your pubspec.yaml
-
-```yaml
-flutter:
-  assets:
-    - assets/audios/
-```
-
-## 🛠️ Getting Started
-
-```Dart
-final assetsAudioPlayer = AssetsAudioPlayer();
-
-assetsAudioPlayer.open(
-    Audio("assets/audios/song1.mp3"),
-);
-```
-
-You can also play *network songs* from *url*
-
-```Dart
-final assetsAudioPlayer = AssetsAudioPlayer();
-
-try {
-    await assetsAudioPlayer.open(
-        Audio.network("http://www.mysite.com/myMp3file.mp3"),
-    );
-} catch (t) {
-    //mp3 unreachable
-}
-```
-
-*LiveStream / Radio* from *url*
-
-**The main difference with network, if you pause/play, on livestream it will resume to present duration**
-
-```Dart
-final assetsAudioPlayer = AssetsAudioPlayer();
-
-try {
-    await assetsAudioPlayer.open(
-        Audio.liveStream(MY_LIVESTREAM_URL),
-    );
-} catch (t) {
-    //stream unreachable
-}
-```
-
-And play *songs from file*
-
-```Dart
-//create a new player
-final assetsAudioPlayer = AssetsAudioPlayer();
-
-assetsAudioPlayer.open(
-    Audio.file(FILE_URI),
-);
-```
-
-for file uri, please look at https://pub.dev/packages/path_provider
-
-```Dart
-assetsAudioPlayer.playOrPause();
-assetsAudioPlayer.play();
-assetsAudioPlayer.pause();
-```
-
-```Dart
-assetsAudioPlayer.seek(Duration to);
-assetsAudioPlayer.seekBy(Duration by);
-```
-
-```Dart
-assetsAudioPlayer.forwardRewind(double speed);
-//if positive, forward, if negative, rewind
-```
-
-```Dart
-assetsAudioPlayer.stop();
-```
-
-
-# Notifications 
-
-
-[![notification](./medias/notification_android.png)](https://github.com/florent37/Flutter-AssetsAudioPlayer)
-
-[![notification](./medias/notification_iOS.png)](https://github.com/florent37/Flutter-AssetsAudioPlayer)
-
-on iOS, it will use `MPNowPlayingInfoCenter`
-
-1. Add metas inside your audio
-
-```dart
-final audio = Audio("/assets/audio/country.mp3", 
-    metas: Metas(
-            title:  "Country",
-            artist: "Florent Champigny",
-            album: "CountryAlbum",
-            image: MetasImage.asset("assets/images/country.jpg"), //can be MetasImage.network
-          ),
-   );
-```
-
-2. open with `showNotification: true`
-
-```dart
-_player.open(audio, showNotification: true)
-```
-
-## Custom notification
-
-Custom icon (android only)
-
-### By ResourceName
-
-Make sur you added those icons inside your `android/res/drawable` **!!! not on flutter assets !!!!**
-
-```dart
-await _assetsAudioPlayer.open(
-        myAudio,
-        showNotification: true,
-        notificationSettings: NotificationSettings(
-            customStopIcon: AndroidResDrawable(name: "ic_stop_custom"),
-            customPauseIcon: AndroidResDrawable(name:"ic_pause_custom"),
-            customPlayIcon: AndroidResDrawable(name:"ic_play_custom"),
-            customPrevIcon: AndroidResDrawable(name:"ic_prev_custom"),
-            customNextIcon: AndroidResDrawable(name:"ic_next_custom"),
-        )
-      
-```
-
-And don't forget tell proguard to keep those resources for release mode
-
-(part Keeping Resources)
-
-https://sites.google.com/a/android.com/tools/tech-docs/new-build-system/resource-shrinking
-
-```xml
-
-<?xml version="1.0" encoding="utf-8"?>
-<resources xmlns:tools="http://schemas.android.com/tools"
-tools:keep="@drawable/ic_next_custom, @drawable/ic_prev_custom, @drawable/ic_pause_custom, @drawable/ic_play_custom, @drawable/ic_stop_custom"/>
-```
-
-### By Manifest
-
-1. Add your icon into your android's `res` folder (android/app/src/main/res)
-
-2. Reference this icon into your AndroidManifest (android/app/src/main/AndroidManifest.xml)
-
-```xml
-<meta-data
-     android:name="assets.audio.player.notification.icon"
-     android:resource="@drawable/ic_music_custom"/>
-```
-
-You can also change actions icons 
-
-```
-<meta-data
-    android:name="assets.audio.player.notification.icon.play"
-    android:resource="@drawable/ic_play_custom"/>
-<meta-data
-    android:name="assets.audio.player.notification.icon.pause"
-    android:resource="@drawable/ic_pause_custom"/>
-<meta-data
-    android:name="assets.audio.player.notification.icon.stop"
-    android:resource="@drawable/ic_stop_custom"/>
-<meta-data
-    android:name="assets.audio.player.notification.icon.next"
-    android:resource="@drawable/ic_next_custom"/>
-<meta-data
-    android:name="assets.audio.player.notification.icon.prev"
-    android:resource="@drawable/ic_prev_custom"/>
-```
-
-## Handle notification click (android)
-
-Add in main 
-```dart
-AssetsAudioPlayer.setupNotificationsOpenAction((notification) {
-    //custom action
-    return true; //true : handled, does not notify others listeners
-                 //false : enable others listeners to handle it
-});
-```
-
-Then if you want a custom action on widget
-
-```dart
-AssetsAudioPlayer.addNotificationOpenAction((notification) {
-   //custom action
-   return false; //true : handled, does not notify others listeners
-                 //false : enable others listeners to handle it
-});
-```
-
-## Custom actions
-
-You can enable/disable a notification action
-
-```dart
-open(AUDIO,
-   showNotification: true,
-   notificationSettings: NotificationSettings(
-       prevEnabled: false, //disable the previous button
-  
-       //and have a custom next action (will disable the default action)
-       customNextAction: (player) {
-         print("next");
-       }
-   )
-
-)
-```
-
-## Update audio's metas / notification content
-
-After your audio creation, just call 
-
-```dart
-audio.updateMetas(
-       player: _assetsAudioPlayer, //add the player if the audio is actually played
-       title: "My new title",
-       artist: "My new artist",
-       //if I not provide a new album, it keep the old one
-       image: MetasImage.network(
-         //my new image url
-       ),
-);
-```
-
-## Bluetooth Actions
- 
-You have to enable notification to make them work
-
-Available remote commands : 
-
-- Play / Pause
-- Next
-- Prev
-- Stop 
-
-## HeadPhone Strategy
-
-(Only for Android for now)
- 
-while opening a song/playlist, add a strategy
-
-```dart
-assetsAudioPlayer.open(
-   ...
-  headPhoneStrategy: HeadPhoneStrategy.pauseOnUnplug,
-  //headPhoneStrategy: HeadPhoneStrategy.none, //default
-  //headPhoneStrategy: HeadPhoneStrategy.pauseOnUnplugPlayOnPlug,
-)
-```
-
-If you want to make it work on bluetooth too, you'll have to add the BLUETOOTH permission inside your AndroidManifest.xml
-
-```xml  
-<uses-permission android:name="android.permission.BLUETOOTH" />
-```
-
-# ⛓ Play in parallel / simultaneously
-
-You can create new AssetsAudioPlayer using AssetsAudioPlayer.newPlayer(), 
-which will play songs in a different native Media Player
-
-This will enable to play two songs simultaneously
-
-You can have as many player as you want !
-
-```dart
-///play 3 songs in parallel
-AssetsAudioPlayer.newPlayer().open(
-    Audio("assets/audios/song1.mp3")
-);
-AssetsAudioPlayer.newPlayer().open(
-    Audio("assets/audios/song2.mp3")
-);
-
-//another way, with create, open, play & dispose the player on finish
-AssetsAudioPlayer.playAndForget(
-    Audio("assets/audios/song3.mp3")
-);
-```
-
-Each player has an unique generated `id`, you can retrieve or create them manually using 
-
-```dart
-final player = AssetsAudioPlayer.withId(id: "MY_UNIQUE_ID");
-```
-
-# 🗄️ Playlist
-```Dart
-assetsAudioPlayer.open(
-  Playlist(
-    audios: [
-      Audio("assets/audios/song1.mp3"),
-      Audio("assets/audios/song2.mp3")
-    ]
-  ),
-  loopMode: LoopMode.playlist //loop the full playlist
-);
-
-assetsAudioPlayer.next();
-assetsAudioPlayer.prev();
-assetsAudioPlayer.playlistPlayAtIndex(1);
-```
-
-## Audio Widget
-
-If you want a more flutter way to play audio, try the `AudioWidget` !
-
-[![sample](./medias/audio_widget.gif)](https://github.com/florent37/Flutter-AssetsAudioPlayer)
-
-```dart
-//inside a stateful widget
-
-bool _play = false;
-
-@override
-Widget build(BuildContext context) {
-  return AudioWidget.assets(
-     path: "assets/audios/country.mp3",
-     play: _play,
-     child: RaisedButton(
-           child: Text(
-               _play ? "pause" : "play",
-           ),
-           onPressed: () {
-               setState(() {
-                 _play = !_play;
-               });
-           }
-      ),
-      onReadyToPlay: (duration) {
-          //onReadyToPlay
-      },
-      onPositionChanged: (current, duration) {
-          //onPositionChanged
-      },
-  );
-}
-```
-
-How to 🛑 stop 🛑 the AudioWidget ?
-
-Just remove the Audio from the tree !
-Or simply keep `play: false`
-
-## 🎧 Listeners
-
-All listeners exposes Streams 
-Using RxDart, AssetsAudioPlayer exposes some listeners as ValueObservable (Observable that provides synchronous access to the last emitted item);
-
-### 🎵 Current song
-```Dart
-//The current playing audio, filled with the total song duration
-assetsAudioPlayer.current //ValueObservable<PlayingAudio>
-
-//Retrieve directly the current played asset
-final PlayingAudio playing = assetsAudioPlayer.current.value;
-
-//Listen to the current playing song
-assetsAudioPlayer.current.listen((playingAudio){
-    final asset = playingAudio.assetAudio;
-    final songDuration = playingAudio.duration;
-})
-```
-
-### ⌛ Current song duration
-
-```Dart
-//Listen to the current playing song
-final duration = assetsAudioPlayer.current.value.duration;
-```
-
-### ⏳ Current position (in seconds)
-
-```Dart
-assetsAudioPlayer.currentPosition //ValueObservable<Duration>
-
-//retrieve directly the current song position
-final Duration position = assetsAudioPlayer.currentPosition.value;
-
-return StreamBuilder(
-    stream: assetsAudioPlayer.currentPosition,
-    builder: (context, asyncSnapshot) {
-        final Duration duration = asyncSnapshot.data;
-        return Text(duration.toString());  
-    }),
-```
-
-or use a PlayerBuilder !
-
-```dart
-PlayerBuilder.currentPosition(
-     player: _assetsAudioPlayer,
-     builder: (context, duration) {
-       return Text(duration.toString());  
-     }
-)
-```
-
-or Player Builder Extension
-
-```dart
-_assetsAudioPlayer.builderCurrentPosition(
-     builder: (context, duration) {
-       return Text(duration.toString());  
-     }
-)
-```
-
-### ▶ IsPlaying
-boolean observable representing the current mediaplayer playing state
-```Dart
-assetsAudioPlayer.isPlaying // ValueObservable<bool>
-
-//retrieve directly the current player state
-final bool playing = assetsAudioPlayer.isPlaying.value;
-
-//will follow the AssetsAudioPlayer playing state
-return StreamBuilder(
-    stream: assetsAudioPlayer.isPlaying,
-    builder: (context, asyncSnapshot) {
-        final bool isPlaying = asyncSnapshot.data;
-        return Text(isPlaying ? "Pause" : "Play");  
-    }),
-```
-
-or use a PlayerBuilder !
-
-```dart
-PlayerBuilder.isPlaying(
-     player: _assetsAudioPlayer,
-     builder: (context, isPlaying) {
-       return Text(isPlaying ? "Pause" : "Play");  
-     }
-)
-```
-
-or Player Builder Extension
-
-```dart
-_assetsAudioPlayer.builderIsPlaying(
-     builder: (context, isPlaying) {
-       return Text(isPlaying ? "Pause" : "Play");  
-     }
-)
-```
-
-### 🔊 Volume
-
-Change the volume (between 0.0 & 1.0)
-```Dart
-assetsAudioPlayer.setVolume(0.5);
-```
-
-The media player can follow the system "volume mode" (vibrate, muted, normal)
-Simply set the `respectSilentMode` optional parameter as `true`
-
-```dart
-_player.open(PLAYABLE, respectSilentMode: true);
-```
-
-https://developer.android.com/reference/android/media/AudioManager.html?hl=fr#getRingerMode()
-
-https://developer.apple.com/documentation/avfoundation/avaudiosessioncategorysoloambient
-
-
-Listen the volume
-
-```dart
-return StreamBuilder(
-    stream: assetsAudioPlayer.volume,
-    builder: (context, asyncSnapshot) {
-        final double volume = asyncSnapshot.data;
-        return Text("volume : $volume");  
-    }),
-```
-
-or use a PlayerBuilder !
-
-```dart
-PlayerBuilder.volume(
-     player: _assetsAudioPlayer,
-     builder: (context, volume) {
-       return Text("volume : $volume");
-     }
-)
-```
-
-### ✋ Finished
-
-Called when the current song has finished to play, 
-
-it gives the Playing audio that just finished
-
-```Dart
-assetsAudioPlayer.playlistAudioFinished //ValueObservable<Playing>
-
-assetsAudioPlayer.playlistAudioFinished.listen((Playing playing){
-    
-})
-```
-
-Called when the complete playlist has finished to play
-
-```Dart
-assetsAudioPlayer.playlistFinished //ValueObservable<bool>
-
-assetsAudioPlayer.playlistFinished.listen((finished){
-    
-})
-```
-
-### 🔁 Looping
-
-```Dart
-final LoopMode loopMode = assetsAudioPlayer.loop; 
-// possible values
-// LoopMode.none : not looping
-// LoopMode.single : looping a single audio
-// LoopMode.playlist : looping the fyll playlist
-
-assetsAudioPlayer.setLoopMode(LoopMode.single);
-
-assetsAudioPlayer.loopMode.listen((loopMode){
-    //listen to loop
-})
-
-assetsAudioPlayer.toggleLoop(); //toggle the value of looping
-```
-
-
-# Error Handling
-
-By default, on playing error, it stop the audio
-
-BUT you can add a custom behavior
-
-```dart
-_player.onErrorDo = (handler){
-  handler.player.stop();
-};
-```
-
-Open another audio
-
-```dart
-_player.onErrorDo = (handler){
-  handler.player.open(ANOTHER_AUDIO);
-};
-```
-
-Try to open again on same position 
-
-```dart
-_player.onErrorDo = (handler){
-  handler.player.open(
-      handler.playlist.copyWith(
-        startIndex: handler.playlistIndex
-      ),
-      seek: handler.currentPosition
-  );
-};
-```
-
-# Network Policies (android/iOS/macOS)
-
-Android only allow HTTPS calls, you will have an error if you're using HTTP, 
-don't forget to add INTERNET permission and seet `usesCleartextTraffic="true"` in your **AndroidManifest.xml**
-
-```
-<?xml version="1.0" encoding="utf-8"?>
-<manifest ...>
-    <uses-permission android:name="android.permission.INTERNET" />
-    <application
-        ...
-        android:usesCleartextTraffic="true"
-        ...>
-        ...
-    </application>
-</manifest>
-```
-
-iOS only allow HTTPS calls, you will have an error if you're using HTTP, 
-don't forget to edit your **info.plist** and set `NSAppTransportSecurity` to `NSAllowsArbitraryLoads`
-
-```
-<key>NSAppTransportSecurity</key>
-<dict>
-    <key>NSAllowsArbitraryLoads</key>
-    <true/>
-</dict>
-```
-
-To enable http calls on macOs, you have to add input/output calls capabilities into `info.plist`
-
-```
-<key>NSAppTransportSecurity</key>
-<dict>
-    <key>NSAllowsArbitraryLoads</key>
-    <true/>
-</dict>
-<key>UIBackgroundModes</key>
-<array>
-    <string>audio</string>
-    <string>fetch</string>
-</array>
-<key>com.apple.security.network.client</key>
-<true/>
-```
-
-and in your
-
-`Runner/DebugProfile.entitlements`
-
-add 
-
-```
-<key>com.apple.security.network.client</key>
-<true/>
-```
-
-Complete `Runner/DebugProfile.entitlements`
-
-```
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>com.apple.security.app-sandbox</key>
-	<true/>
-	<key>com.apple.security.cs.allow-jit</key>
-	<true/>
-	<key>com.apple.security.network.server</key>
-	<true/>
-	<key>com.apple.security.network.client</key>
-	<true/>
-</dict>
-</plist>
-```
-
-# 🎶 Musics
-
-All musics used in the samples came from https://www.freemusicarchive.org/
diff --git a/assets_audio_player_web/analysis_options.yaml b/assets_audio_player_web/analysis_options.yaml
deleted file mode 100644
index f9b3034..0000000
--- a/assets_audio_player_web/analysis_options.yaml
+++ /dev/null
@@ -1 +0,0 @@
-include: package:flutter_lints/flutter.yaml
diff --git a/assets_audio_player_web/android/.gitignore b/assets_audio_player_web/android/.gitignore
deleted file mode 100644
index c6cbe56..0000000
--- a/assets_audio_player_web/android/.gitignore
+++ /dev/null
@@ -1,8 +0,0 @@
-*.iml
-.gradle
-/local.properties
-/.idea/workspace.xml
-/.idea/libraries
-.DS_Store
-/build
-/captures
diff --git a/assets_audio_player_web/android/build.gradle b/assets_audio_player_web/android/build.gradle
deleted file mode 100644
index 7a21ee5..0000000
--- a/assets_audio_player_web/android/build.gradle
+++ /dev/null
@@ -1,57 +0,0 @@
-group 'com.github.florent37.assets_audio_player_web'
-version '1.0-SNAPSHOT'
-
-//Eirik 14.08.24: buildscript block removed as recommended, see https://flutter.dev/go/flutter-gradle-plugin-apply
-//buildscript {
-//    ext.kotlin_version = '1.3.50'
-//    repositories {
-//        google()
-//        jcenter()
-//    }
-
-//    dependencies {
-//        classpath 'com.android.tools.build:gradle:3.5.0'
-//        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
-//    }
-//}
-
-rootProject.allprojects {
-    repositories {
-        google()
-        mavenCentral()
-    }
-}
-
-apply plugin: 'com.android.library'
-apply plugin: 'kotlin-android'
-
-android {
-    compileSdkVersion 34 // Eirik 10.09.24: Changed from 28
-/*
-    compileOptions { //Eirik 10.09.24: Try to force Java 1.8
-        sourceCompatibility JavaVersion.VERSION_1_8
-        targetCompatibility JavaVersion.VERSION_1_8
-    } */
-    compileOptions { //Eirik 10.09.24: Try to force Java 17(?)
-        sourceCompatibility JavaVersion.VERSION_17
-        targetCompatibility JavaVersion.VERSION_17
-    }
-    sourceSets {
-        main.java.srcDirs += 'src/main/kotlin'
-    }
-    defaultConfig {
-        minSdkVersion 16
-    }
-    lintOptions {
-        disable 'InvalidPackage'
-    }
-    //Eirik 13.09.24: Added
-    kotlinOptions {
-        jvmTarget = '17'
-    }
-}
-
-dependencies {
-    //implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version" //Eirik 10.09.24: Testing TODO!  removing this
-    implementation "androidx.annotation:annotation:1.8.2" // Eirik 10.09.24: Changed from 1.1.0
-}
diff --git a/assets_audio_player_web/android/gradle.properties b/assets_audio_player_web/android/gradle.properties
deleted file mode 100644
index 38c8d45..0000000
--- a/assets_audio_player_web/android/gradle.properties
+++ /dev/null
@@ -1,4 +0,0 @@
-org.gradle.jvmargs=-Xmx1536M
-android.enableR8=true
-android.useAndroidX=true
-android.enableJetifier=true
diff --git a/assets_audio_player_web/android/gradle/wrapper/gradle-wrapper.properties b/assets_audio_player_web/android/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 296b146..0000000
--- a/assets_audio_player_web/android/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Fri Jun 23 08:50:38 CEST 2017
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-5.6.2-all.zip
diff --git a/assets_audio_player_web/android/settings.gradle b/assets_audio_player_web/android/settings.gradle
deleted file mode 100644
index f47a2dd..0000000
--- a/assets_audio_player_web/android/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'assets_audio_player_web'
diff --git a/assets_audio_player_web/android/src/main/AndroidManifest.xml b/assets_audio_player_web/android/src/main/AndroidManifest.xml
deleted file mode 100644
index ce0a935..0000000
--- a/assets_audio_player_web/android/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,3 +0,0 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-  package="com.github.florent37.assets_audio_player_web">
-</manifest>
diff --git a/assets_audio_player_web/android/src/main/kotlin/com/github/florent37/assets_audio_player_web/AssetsAudioPlayerWebPlugin.kt b/assets_audio_player_web/android/src/main/kotlin/com/github/florent37/assets_audio_player_web/AssetsAudioPlayerWebPlugin.kt
deleted file mode 100644
index 76e1a20..0000000
--- a/assets_audio_player_web/android/src/main/kotlin/com/github/florent37/assets_audio_player_web/AssetsAudioPlayerWebPlugin.kt
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.github.florent37.assets_audio_player_web
-
-import androidx.annotation.NonNull;
-
-import io.flutter.embedding.engine.plugins.FlutterPlugin
-import io.flutter.plugin.common.MethodCall
-import io.flutter.plugin.common.MethodChannel
-import io.flutter.plugin.common.MethodChannel.MethodCallHandler
-import io.flutter.plugin.common.MethodChannel.Result
-import io.flutter.plugin.common.PluginRegistry.Registrar
-
-/** AssetsAudioPlayerWebPlugin */
-public class AssetsAudioPlayerWebPlugin: FlutterPlugin, MethodCallHandler {
-
-  private lateinit var channel : MethodChannel
-
-  override fun onAttachedToEngine(@NonNull flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) {
-    //no-op for compatibility
-  }
-
-  companion object {
-    @JvmStatic
-    fun registerWith(registrar: Registrar) {
-      //no-op for compatibility
-    }
-  }
-
-  override fun onMethodCall(@NonNull call: MethodCall, @NonNull result: Result) {
-    //no-op for compatibility
-  }
-
-  override fun onDetachedFromEngine(@NonNull binding: FlutterPlugin.FlutterPluginBinding) {
-    //no-op for compatibility
-  }
-}
diff --git a/assets_audio_player_web/ios/.gitignore b/assets_audio_player_web/ios/.gitignore
deleted file mode 100644
index aa479fd..0000000
--- a/assets_audio_player_web/ios/.gitignore
+++ /dev/null
@@ -1,37 +0,0 @@
-.idea/
-.vagrant/
-.sconsign.dblite
-.svn/
-
-.DS_Store
-*.swp
-profile
-
-DerivedData/
-build/
-GeneratedPluginRegistrant.h
-GeneratedPluginRegistrant.m
-
-.generated/
-
-*.pbxuser
-*.mode1v3
-*.mode2v3
-*.perspectivev3
-
-!default.pbxuser
-!default.mode1v3
-!default.mode2v3
-!default.perspectivev3
-
-xcuserdata
-
-*.moved-aside
-
-*.pyc
-*sync/
-Icon?
-.tags*
-
-/Flutter/Generated.xcconfig
-/Flutter/flutter_export_environment.sh
\ No newline at end of file
diff --git a/assets_audio_player_web/ios/Assets/.gitkeep b/assets_audio_player_web/ios/Assets/.gitkeep
deleted file mode 100644
index e69de29..0000000
diff --git a/assets_audio_player_web/ios/Classes/AssetsAudioPlayerWebPlugin.h b/assets_audio_player_web/ios/Classes/AssetsAudioPlayerWebPlugin.h
deleted file mode 100644
index 8c44c87..0000000
--- a/assets_audio_player_web/ios/Classes/AssetsAudioPlayerWebPlugin.h
+++ /dev/null
@@ -1,4 +0,0 @@
-#import <Flutter/Flutter.h>
-
-@interface AssetsAudioPlayerWebPlugin : NSObject<FlutterPlugin>
-@end
diff --git a/assets_audio_player_web/ios/Classes/AssetsAudioPlayerWebPlugin.m b/assets_audio_player_web/ios/Classes/AssetsAudioPlayerWebPlugin.m
deleted file mode 100644
index 015af03..0000000
--- a/assets_audio_player_web/ios/Classes/AssetsAudioPlayerWebPlugin.m
+++ /dev/null
@@ -1,15 +0,0 @@
-#import "AssetsAudioPlayerWebPlugin.h"
-#if __has_include(<assets_audio_player_web/assets_audio_player_web-Swift.h>)
-#import <assets_audio_player_web/assets_audio_player_web-Swift.h>
-#else
-// Support project import fallback if the generated compatibility header
-// is not copied when this plugin is created as a library.
-// https://forums.swift.org/t/swift-static-libraries-dont-copy-generated-objective-c-header/19816
-#import "assets_audio_player_web-Swift.h"
-#endif
-
-@implementation AssetsAudioPlayerWebPlugin
-+ (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar>*)registrar {
-  [SwiftAssetsAudioPlayerWebPlugin registerWithRegistrar:registrar];
-}
-@end
diff --git a/assets_audio_player_web/ios/Classes/SwiftAssetsAudioPlayerWebPlugin.swift b/assets_audio_player_web/ios/Classes/SwiftAssetsAudioPlayerWebPlugin.swift
deleted file mode 100644
index a40941c..0000000
--- a/assets_audio_player_web/ios/Classes/SwiftAssetsAudioPlayerWebPlugin.swift
+++ /dev/null
@@ -1,12 +0,0 @@
-import Flutter
-import UIKit
-
-public class SwiftAssetsAudioPlayerWebPlugin: NSObject, FlutterPlugin {
-  public static func register(with registrar: FlutterPluginRegistrar) {
-    //no-op for compatibility
-  }
-
-  public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
-      //no-op for compatibility
-  }
-}
diff --git a/assets_audio_player_web/ios/assets_audio_player_web.podspec b/assets_audio_player_web/ios/assets_audio_player_web.podspec
deleted file mode 100644
index 8a24cf1..0000000
--- a/assets_audio_player_web/ios/assets_audio_player_web.podspec
+++ /dev/null
@@ -1,23 +0,0 @@
-#
-# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html.
-# Run `pod lib lint assets_audio_player_web.podspec' to validate before publishing.
-#
-Pod::Spec.new do |s|
-  s.name             = 'assets_audio_player_web'
-  s.version          = '0.0.1'
-  s.summary          = 'A new Flutter plugin.'
-  s.description      = <<-DESC
-A new Flutter plugin.
-                       DESC
-  s.homepage         = 'http://example.com'
-  s.license          = { :file => '../LICENSE' }
-  s.author           = { 'Your Company' => 'email@example.com' }
-  s.source           = { :path => '.' }
-  s.source_files = 'Classes/**/*'
-  s.dependency 'Flutter'
-  s.platform = :ios, '8.0'
-
-  # Flutter.framework does not contain a i386 slice. Only x86_64 simulators are supported.
-  s.pod_target_xcconfig = { 'DEFINES_MODULE' => 'YES', 'VALID_ARCHS[sdk=iphonesimulator*]' => 'x86_64' }
-  s.swift_version = '5.0'
-end
diff --git a/assets_audio_player_web/lib/assets_audio_player_web.dart b/assets_audio_player_web/lib/assets_audio_player_web.dart
deleted file mode 100644
index 8b13789..0000000
--- a/assets_audio_player_web/lib/assets_audio_player_web.dart
+++ /dev/null
@@ -1 +0,0 @@
-
diff --git a/assets_audio_player_web/lib/generated/i18n.dart b/assets_audio_player_web/lib/generated/i18n.dart
deleted file mode 100644
index 6d0e90c..0000000
--- a/assets_audio_player_web/lib/generated/i18n.dart
+++ /dev/null
@@ -1,130 +0,0 @@
-// import 'dart:async';
-
-// import 'package:flutter/foundation.dart';
-// import 'package:flutter/material.dart';
-
-// // ignore_for_file: non_constant_identifier_names
-// // ignore_for_file: camel_case_types
-// // ignore_for_file: prefer_single_quotes
-
-// // This file is automatically generated. DO NOT EDIT, all your changes would be lost.
-// class S implements WidgetsLocalizations {
-//   const S();
-
-//   static S current;
-
-//   static const GeneratedLocalizationsDelegate delegate =
-//       GeneratedLocalizationsDelegate();
-
-//   static S of(BuildContext context) => Localizations.of<S>(context, S);
-
-//   @override
-//   TextDirection get textDirection => TextDirection.ltr;
-// }
-
-// class $en extends S {
-//   const $en();
-// }
-
-// class GeneratedLocalizationsDelegate extends LocalizationsDelegate<S> {
-//   const GeneratedLocalizationsDelegate();
-
-//   List<Locale> get supportedLocales {
-//     return const <Locale>[
-//       Locale('en', ''),
-//     ];
-//   }
-
-//   LocaleListResolutionCallback listResolution(
-//       {Locale fallback, bool withCountry = true}) {
-//     return (List<Locale> locales, Iterable<Locale> supported) {
-//       if (locales == null || locales.isEmpty) {
-//         return fallback ?? supported.first;
-//       } else {
-//         return _resolve(locales.first, fallback, supported, withCountry);
-//       }
-//     };
-//   }
-
-//   LocaleResolutionCallback resolution(
-//       {Locale fallback, bool withCountry = true}) {
-//     return (Locale locale, Iterable<Locale> supported) {
-//       return _resolve(locale, fallback, supported, withCountry);
-//     };
-//   }
-
-//   @override
-//   Future<S> load(Locale locale) {
-//     final String lang = getLang(locale);
-//     if (lang != null) {
-//       switch (lang) {
-//         case 'en':
-//           S.current = const $en();
-//           return SynchronousFuture<S>(S.current);
-//         default:
-//         // NO-OP.
-//       }
-//     }
-//     S.current = const S();
-//     return SynchronousFuture<S>(S.current);
-//   }
-
-//   @override
-//   bool isSupported(Locale locale) => _isSupported(locale, true);
-
-//   @override
-//   bool shouldReload(GeneratedLocalizationsDelegate old) => false;
-
-//   ///
-//   /// Internal method to resolve a locale from a list of locales.
-//   ///
-//   Locale _resolve(Locale locale, Locale fallback, Iterable<Locale> supported,
-//       bool withCountry) {
-//     if (locale == null || !_isSupported(locale, withCountry)) {
-//       return fallback ?? supported.first;
-//     }
-
-//     final Locale languageLocale = Locale(locale.languageCode, '');
-//     if (supported.contains(locale)) {
-//       return locale;
-//     } else if (supported.contains(languageLocale)) {
-//       return languageLocale;
-//     } else {
-//       final Locale fallbackLocale = fallback ?? supported.first;
-//       return fallbackLocale;
-//     }
-//   }
-
-//   ///
-//   /// Returns true if the specified locale is supported, false otherwise.
-//   ///
-//   bool _isSupported(Locale locale, bool withCountry) {
-//     if (locale != null) {
-//       for (Locale supportedLocale in supportedLocales) {
-//         // Language must always match both locales.
-//         if (supportedLocale.languageCode != locale.languageCode) {
-//           continue;
-//         }
-
-//         // If country code matches, return this locale.
-//         if (supportedLocale.countryCode == locale.countryCode) {
-//           return true;
-//         }
-
-//         // If no country requirement is requested, check if this locale has no country.
-//         if (true != withCountry &&
-//             (supportedLocale.countryCode == null ||
-//                 supportedLocale.countryCode.isEmpty)) {
-//           return true;
-//         }
-//       }
-//     }
-//     return false;
-//   }
-// }
-
-// String getLang(Locale l) => l == null
-//     ? null
-//     : l.countryCode != null && l.countryCode.isEmpty
-//         ? l.languageCode
-//         : l.toString();
diff --git a/assets_audio_player_web/lib/web/abstract_web_player.dart b/assets_audio_player_web/lib/web/abstract_web_player.dart
deleted file mode 100644
index fb4da9e..0000000
--- a/assets_audio_player_web/lib/web/abstract_web_player.dart
+++ /dev/null
@@ -1,78 +0,0 @@
-import 'dart:async';
-import 'dart:html';
-
-import 'package:flutter/services.dart';
-
-/// Web Player
-abstract class WebPlayer {
-  final MethodChannel channel;
-
-  static final methodPosition = 'player.position';
-  static final methodVolume = 'player.volume';
-  static final methodPlaySpeed = 'player.playSpeed';
-  static final methodFinished = 'player.finished';
-  static final methodIsPlaying = 'player.isPlaying';
-  static final methodIsBuffering = 'player.isBuffering';
-  static final methodCurrent = 'player.current';
-  static final methodForwardRewindSpeed = 'player.forwardRewind';
-
-  WebPlayer({required this.channel});
-
-  num get volume;
-
-  set volume(num volume);
-
-  num get playSpeed;
-
-  set playSpeed(num playSpeed);
-
-  bool get isPlaying;
-
-  set isPlaying(bool value);
-
-  num get currentPosition;
-
-  void play();
-
-  void pause();
-
-  void stop();
-
-  String findAssetPath(String path, String audioType, {String? package}) {
-    if (audioType == 'network' ||
-        audioType == 'liveStream' ||
-        audioType == 'file') {
-      return path;
-    }
-    // in web, assets are packaged in a /assets/ folder
-    // if you want '/asset/3' as described in pubspec
-    // it will be in /assets/asset/3
-
-    /* for release mode, need to change the 'url', remove the /#/ and add /asset before */
-    if (path.startsWith('/')) {
-      path = path.replaceFirst('/', '');
-    }
-    if (package != null) {
-      path = 'packages/$package/' + path;
-    }
-    path = (window.location.href.replaceAll('/#/', '') + '/assets/' + path);
-    return path;
-  }
-
-  Future<void> open({
-    required String path,
-    required String audioType,
-    bool autoStart = false,
-    double volume = 1,
-    double? seek,
-    double? playSpeed,
-    Map? networkHeaders,
-    String? package,
-  });
-
-  void seek({double to});
-
-  void forwardRewind(double speed);
-
-  void loopSingleAudio(bool loop);
-}
diff --git a/assets_audio_player_web/lib/web/assets_audio_player_web.dart b/assets_audio_player_web/lib/web/assets_audio_player_web.dart
deleted file mode 100644
index 863fbd7..0000000
--- a/assets_audio_player_web/lib/web/assets_audio_player_web.dart
+++ /dev/null
@@ -1,115 +0,0 @@
-import 'dart:async';
-
-import 'package:assets_audio_player_web/web/web_player_html.dart';
-import 'package:flutter/services.dart';
-import 'package:flutter_web_plugins/flutter_web_plugins.dart';
-
-import 'abstract_web_player.dart';
-
-/// Web plugin
-class AssetsAudioPlayerWebPlugin {
-  final Map<String, WebPlayer> _players = {};
-  final BinaryMessenger messenger;
-
-  AssetsAudioPlayerWebPlugin({required this.messenger});
-
-  WebPlayer _newPlayer(String id, MethodChannel channel) {
-    return WebPlayerHtml(
-      channel: channel,
-    );
-  }
-
-  WebPlayer _getOrCreate(String id) {
-    if (_players.containsKey(id)) {
-      return _players[id]!;
-    } else {
-      final newPlayer = _newPlayer(
-          id,
-          MethodChannel(
-            'assets_audio_player/' + id,
-            const StandardMethodCodec(),
-            messenger,
-          ));
-      _players[id] = newPlayer;
-      return newPlayer;
-    }
-  }
-
-  static void registerWith(Registrar registrar) {
-    final channel = MethodChannel(
-      'assets_audio_player',
-      const StandardMethodCodec(),
-      registrar,
-    );
-    final instance = AssetsAudioPlayerWebPlugin(messenger: registrar);
-    channel.setMethodCallHandler(instance.handleMethodCall);
-  }
-
-  Future<dynamic> handleMethodCall(MethodCall call) async {
-    //print(call.method);
-    switch (call.method) {
-      case 'isPlaying':
-        final String id = call.arguments['id'];
-        return Future.value(_getOrCreate(id).isPlaying);
-      case 'play':
-        final String id = call.arguments['id'];
-        _getOrCreate(id).play();
-        return Future.value(true);
-      case 'pause':
-        final String id = call.arguments['id'];
-        _getOrCreate(id).pause();
-        return Future.value(true);
-      case 'stop':
-        final String id = call.arguments['id'];
-        _getOrCreate(id).stop();
-        return Future.value(true);
-      case 'volume':
-        final String id = call.arguments['id'];
-        final double volume = call.arguments['volume'];
-        _getOrCreate(id).volume = volume;
-        return Future.value(true);
-      case 'playSpeed':
-        final String id = call.arguments['id'];
-        final double playSpeed = call.arguments['playSpeed'];
-        _getOrCreate(id).playSpeed = playSpeed;
-        return Future.value(true);
-      case 'forwardRewind':
-        final String id = call.arguments['id'];
-        final double speed = call.arguments['speed'];
-        _getOrCreate(id).forwardRewind(speed);
-        return Future.value(true);
-      case 'loopSingleAudio':
-        final String id = call.arguments['id'];
-        final bool loop = call.arguments['loop'];
-        _getOrCreate(id).loopSingleAudio(loop);
-        return Future.value(true);
-      case 'seek':
-        final String id = call.arguments['id'];
-        final double to = call.arguments['to'];
-        _getOrCreate(id).seek(
-          to: to,
-        );
-        return Future.value(true);
-      case 'open':
-        final String id = call.arguments['id'];
-        final String path = call.arguments['path'];
-        final String audioType = call.arguments['audioType'];
-        final double volume = call.arguments['volume'];
-        final double? seek = call.arguments['seek'];
-        final double playSpeed = call.arguments['playSpeed'];
-        final bool autoStart = call.arguments['autoStart'] ?? true;
-        final Map? networkHeaders = call.arguments['networkHeaders'];
-        final String? package = call.arguments['package'];
-        return _getOrCreate(id).open(
-          path: path,
-          audioType: audioType,
-          volume: volume,
-          seek: seek,
-          playSpeed: playSpeed,
-          autoStart: autoStart,
-          networkHeaders: networkHeaders,
-          package: package,
-        );
-    }
-  }
-}
diff --git a/assets_audio_player_web/lib/web/web_player_html.dart b/assets_audio_player_web/lib/web/web_player_html.dart
deleted file mode 100644
index 9c5f31a..0000000
--- a/assets_audio_player_web/lib/web/web_player_html.dart
+++ /dev/null
@@ -1,228 +0,0 @@
-import 'dart:async';
-import 'dart:html' as html;
-
-import 'package:flutter/services.dart';
-
-import 'abstract_web_player.dart';
-
-/// Web Player
-class WebPlayerHtml extends WebPlayer {
-  @override
-  WebPlayerHtml({required MethodChannel channel}) : super(channel: channel);
-
-  StreamSubscription? _onEndListener;
-  StreamSubscription? _onCanPlayListener;
-
-  void _clearListeners() {
-    _onEndListener?.cancel();
-    _onCanPlayListener?.cancel();
-  }
-
-  html.AudioElement? _audioElement;
-
-  @override
-  num get volume => _audioElement?.volume ?? 1.0;
-
-  @override
-  set volume(num volume) {
-    _audioElement?.volume = volume;
-    channel.invokeMethod(WebPlayer.methodVolume, volume);
-  }
-
-  @override
-  num get playSpeed => _audioElement?.playbackRate ?? 1.0;
-
-  @override
-  set playSpeed(num playSpeed) {
-    _audioElement?.playbackRate = playSpeed;
-    channel.invokeMethod(WebPlayer.methodPlaySpeed, playSpeed);
-  }
-
-  bool _isPlaying = false;
-
-  @override
-  bool get isPlaying => _isPlaying;
-
-  @override
-  set isPlaying(bool value) {
-    _isPlaying = value;
-    channel.invokeMethod(WebPlayer.methodIsPlaying, value);
-    if (value) {
-      _listenPosition();
-    } else {
-      _stopListenPosition();
-    }
-  }
-
-  @override
-  num get currentPosition => _audioElement?.currentTime ?? 0;
-
-  var __listenPosition = false;
-
-  num? _durationMs;
-  num? _position;
-
-  void _listenPosition() async {
-    __listenPosition = true;
-    await Future.doWhile(() {
-      final durationMs = (_audioElement?.duration ?? 0) * 1000;
-      if (durationMs != _durationMs) {
-        _durationMs = durationMs;
-        channel.invokeMethod(
-            WebPlayer.methodCurrent, {'totalDurationMs': durationMs});
-      }
-
-      if (_position != currentPosition) {
-        _position = currentPosition;
-        final positionMs = currentPosition * 1000;
-        channel.invokeMethod(WebPlayer.methodPosition, positionMs);
-      }
-      return Future.delayed(Duration(milliseconds: 200)).then((value) {
-        return __listenPosition;
-      });
-    });
-  }
-
-  void _stopListenPosition() {
-    __listenPosition = false;
-  }
-
-  @override
-  void play() {
-    if (_audioElement != null) {
-      isPlaying = true;
-      forwardHandler?.stop();
-      _audioElement?.play();
-    }
-  }
-
-  @override
-  void pause() {
-    if (_audioElement != null) {
-      isPlaying = false;
-      forwardHandler?.stop();
-      _audioElement?.pause();
-    }
-  }
-
-  @override
-  void stop() {
-    forwardHandler?.stop();
-    forwardHandler = null;
-
-    _clearListeners();
-
-    if (_audioElement != null) {
-      isPlaying = false;
-      pause();
-      _audioElement?.currentTime = 0;
-      channel.invokeMethod(WebPlayer.methodPosition, 0);
-    }
-  }
-
-  @override
-  Future<void> open({
-    required String path,
-    required String audioType,
-    String? package,
-    bool autoStart = false,
-    double volume = 1,
-    double? seek,
-    double? playSpeed,
-    Map? networkHeaders,
-  }) async {
-    stop();
-    _durationMs = null;
-    _position = null;
-    _audioElement = html.AudioElement(findAssetPath(
-      path,
-      audioType,
-      package: package,
-    ));
-
-    // it seems html audielement cannot take networkHeaders :'(
-
-    _onEndListener = _audioElement?.onEnded.listen((event) {
-      channel.invokeMethod(WebPlayer.methodFinished, true);
-    });
-
-    _onCanPlayListener = _audioElement?.onCanPlay.listen((event) {
-      if (autoStart) {
-        play();
-      }
-
-      this.volume = volume;
-      final durationMs = (_audioElement?.duration ?? 0) * 1000;
-
-      if (durationMs != _durationMs) {
-        _durationMs = durationMs;
-        channel.invokeMethod(
-            WebPlayer.methodCurrent, {'totalDurationMs': durationMs});
-      }
-
-      if (seek != null) {
-        this.seek(to: seek);
-      }
-
-      if (playSpeed != null) {
-        this.playSpeed = playSpeed;
-      }
-
-      // single event
-      _onCanPlayListener?.cancel();
-      _onCanPlayListener = null;
-    });
-  }
-
-  @override
-  void seek({double? to}) {
-    print('Final Seeking To $to from ${_audioElement?.currentTime}');
-    if (_audioElement != null && to != null) {
-      /// Explainer on the `/1000`
-      /// The value being sent down from the plugin
-      /// is in `milliseconds` and `AudioElement` uses seconds.
-      /// This is to convert it.
-      final toInSeconds = to / 1000;
-      _audioElement?.currentTime = toInSeconds;
-    }
-  }
-
-  @override
-  void loopSingleAudio(bool loop) {
-    _audioElement?.loop = loop;
-  }
-
-  void seekBy({required double by}) {
-    final current = currentPosition;
-    final to = current + by;
-    seek(to: to);
-  }
-
-  ForwardHandler? forwardHandler;
-  @override
-  void forwardRewind(double speed) {
-    pause();
-    channel.invokeMethod(WebPlayer.methodForwardRewindSpeed, speed);
-    forwardHandler?.stop();
-    forwardHandler = ForwardHandler();
-    _listenPosition(); // for this usecase, enable listen position
-    forwardHandler?.start(this, speed);
-  }
-}
-
-class ForwardHandler {
-  bool _isEnabled = false;
-  static final _timelapse = 300;
-
-  void start(WebPlayerHtml player, double speed) async {
-    _isEnabled = true;
-    while (_isEnabled) {
-      player.seekBy(by: speed * _timelapse);
-      await Future.delayed(Duration(milliseconds: _timelapse));
-    }
-  }
-
-  void stop() {
-    _isEnabled = false;
-  }
-}
diff --git a/assets_audio_player_web/macos/Classes/AssetsAudioPlayerWebPlugin.swift b/assets_audio_player_web/macos/Classes/AssetsAudioPlayerWebPlugin.swift
deleted file mode 100644
index cc6b438..0000000
--- a/assets_audio_player_web/macos/Classes/AssetsAudioPlayerWebPlugin.swift
+++ /dev/null
@@ -1,19 +0,0 @@
-import Cocoa
-import FlutterMacOS
-
-public class AssetsAudioPlayerWebPlugin: NSObject, FlutterPlugin {
-  public static func register(with registrar: FlutterPluginRegistrar) {
-    let channel = FlutterMethodChannel(name: "assets_audio_player_web", binaryMessenger: registrar.messenger)
-    let instance = AssetsAudioPlayerWebPlugin()
-    registrar.addMethodCallDelegate(instance, channel: channel)
-  }
-
-  public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
-    switch call.method {
-    case "getPlatformVersion":
-      result("macOS " + ProcessInfo.processInfo.operatingSystemVersionString)
-    default:
-      result(FlutterMethodNotImplemented)
-    }
-  }
-}
diff --git a/assets_audio_player_web/macos/assets_audio_player_web.podspec b/assets_audio_player_web/macos/assets_audio_player_web.podspec
deleted file mode 100644
index 264b2a9..0000000
--- a/assets_audio_player_web/macos/assets_audio_player_web.podspec
+++ /dev/null
@@ -1,22 +0,0 @@
-#
-# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html.
-# Run `pod lib lint assets_audio_player_web.podspec' to validate before publishing.
-#
-Pod::Spec.new do |s|
-  s.name             = 'assets_audio_player_web'
-  s.version          = '0.0.1'
-  s.summary          = 'A new Flutter plugin.'
-  s.description      = <<-DESC
-A new Flutter plugin.
-                       DESC
-  s.homepage         = 'http://example.com'
-  s.license          = { :file => '../LICENSE' }
-  s.author           = { 'Your Company' => 'email@example.com' }
-  s.source           = { :path => '.' }
-  s.source_files     = 'Classes/**/*'
-  s.dependency 'FlutterMacOS'
-
-  s.platform = :osx, '10.11'
-  s.pod_target_xcconfig = { 'DEFINES_MODULE' => 'YES' }
-  s.swift_version = '5.0'
-end
diff --git a/assets_audio_player_web/publish.sh b/assets_audio_player_web/publish.sh
deleted file mode 100644
index ddec506..0000000
--- a/assets_audio_player_web/publish.sh
+++ /dev/null
@@ -1,2 +0,0 @@
-flutter format lib/
-pub publish --force
\ No newline at end of file
diff --git a/assets_audio_player_web/pubspec.yaml b/assets_audio_player_web/pubspec.yaml
deleted file mode 100644
index ca5922c..0000000
--- a/assets_audio_player_web/pubspec.yaml
+++ /dev/null
@@ -1,35 +0,0 @@
-name: assets_audio_player_web
-description: Web plugin for assets_audio_player, play music/audio stored in assets files directly from Flutter.
-version: 3.1.1
-#author: Florent Champigny <champigny.florent@gmail.com>
-homepage: https://github.com/florent37/Flutter-AssetsAudioPlayer
-
-environment:
-  sdk: ">=2.18.0 <4.0.0"
-  flutter: ">=3.3.0"
-
-dependencies:
-  flutter:
-    sdk: flutter
-  flutter_web_plugins:
-    sdk: flutter
-
-dev_dependencies:
-  flutter_test:
-    sdk: flutter
-  flutter_lints: ^2.0.2
-
-# For information on the generic Dart part of this file, see the
-# following page: https://dart.dev/tools/pub/pubspec
-
-# The following section is specific to Flutter.
-flutter:
-  # This section identifies this Flutter project as a plugin project.
-  # The 'pluginClass' and Android 'package' identifiers should not ordinarily
-  # be modified. They are used by the tooling to maintain consistency when
-  # adding or updating assets for this project.
-  plugin:
-    platforms:
-      web:
-        pluginClass: AssetsAudioPlayerWebPlugin
-        fileName: web/assets_audio_player_web.dart
diff --git a/assets_audio_player_web/res/values/strings_en.arb b/assets_audio_player_web/res/values/strings_en.arb
deleted file mode 100644
index 9e26dfe..0000000
--- a/assets_audio_player_web/res/values/strings_en.arb
+++ /dev/null
@@ -1 +0,0 @@
-{}
\ No newline at end of file
diff --git a/assets_audio_player_web/test/assets_audio_player_web_test.dart b/assets_audio_player_web/test/assets_audio_player_web_test.dart
deleted file mode 100644
index ab73b3a..0000000
--- a/assets_audio_player_web/test/assets_audio_player_web_test.dart
+++ /dev/null
@@ -1 +0,0 @@
-void main() {}
diff --git a/build.gradle.kts b/build.gradle.kts
index e69de29..e4163a7 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -0,0 +1,25 @@
+/*plugins {
+    id("com.android.library") //apply false
+    id("org.jetbrains.kotlin.android") //apply false
+    id("dev.flutter.flutter-gradle-plugin") //apply false
+}
+*/
+/*
+buildscript {
+    repositories {
+        google()
+        mavenCentral()
+    }
+    dependencies {
+        classpath("com.android.tools.build:gradle:8.4.2")
+        classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:1.9.22")
+    }
+}
+*/
+
+//tasks.register("clean", Delete::class) {
+    //java.nio.file.Files.delete(rootProject.buildDir.toPath())
+//    delete(rootProject.buildDir)
+tasks.register<Delete>("clean") {
+    delete(layout.buildDirectory)
+}
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index e69de29..61e1ed7 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -0,0 +1,4 @@
+flutter.hostAppProjectName=android
+android.useAndroidX = true
+org.gradle.java.home=F\:\\java\\Eclipse Adoptium\\jdk-17.0.15.6-hotspot
+
diff --git a/local.properties b/local.properties
index 0976e49..b98d89f 100644
--- a/local.properties
+++ b/local.properties
@@ -4,5 +4,6 @@
 # Location of the SDK. This is only used by Gradle.
 # For customization when using a Version Control System, please read the
 # header note.
-#Fri May 02 13:45:41 IST 2025
-sdk.dir=E\:\\Develop\\Android\\SDK
+#Sun May 04 17:58:33 IST 2025
+flutter.sdk=F\:\\flutter
+sdk.dir=F\:\\Android\\SDK
diff --git a/pubspec.yaml b/pubspec.yaml
index ea2086e..620dd4f 100644
--- a/pubspec.yaml
+++ b/pubspec.yaml
@@ -2,19 +2,21 @@ name: assets_audio_player
 description: Play music/audio stored in assets files directly from Flutter & Network, Radio, LiveStream, Local files. Compatible with Android, iOS, web and macOS.
 version: 4.0.0
 
-author: Florent Champigny <champigny.florent@gmail.com>
 homepage: https://github.com/florent37/Flutter-AssetsAudioPlayer
 
 environment:
   sdk: '>=2.19.0 <4.0.0'
   flutter: '>=3.3.0'
+  #flutter: ^3.0.0
 
 dependencies:
   flutter:
     sdk: flutter
-  rxdart: ^0.27.7
+  rxdart: ^0.28.0
   uuid: ">=3.0.7 <5.0.0"
+  #uuid: ^4.0.0
   http: ">=0.13.0 <2.0.0" # to download / cache network files
+  #http: ^1.0.0 # to download / cache network files
   path_provider: ^2.0.8 # removed this because it cancel flutter/android/ios on pub.dev path_provider: ^1.6.10
 
 
@@ -29,23 +31,27 @@ dependencies:
 dev_dependencies:
   flutter_test:
     sdk: flutter
-  flutter_lints: ^2.0.2
+  #Eirik 15.05.25: Downgraded Flutter from 3.29.2 to 3.22.2 due to error in Flutter version
+  #Flutter version 3.22.2 is pinned to Dart 3.4.3. flutter_lints require Dart 3.5.0 or higher
+  #Work-around: Downgraded flutter_lints from 5.0.0 to 2.0.0
+  #flutter_lints: ^5.0.0
+  flutter_lints: ^2.0.0
 
 flutter:
   plugin:
-        platforms:
-          android:
-            package: com.github.florent37.assets_audio_player
-    #        #package: .\assets_audio_player
-            pluginClass: AssetsAudioPlayerPlugin
-    #        mainClass: AssetsAudioPlayerPlugin
-          ios:
-            pluginClass: AssetsAudioPlayerPlugin
-    #      macos:
-    #        pluginClass: AssetsAudioPlayerPlugin
-#      web:
-#        default_package: assets_audio_player_web
-      # moved to assets_audio_player_web
-      # web:
-      #  pluginClass: AssetsAudioPlayerPlugin
-      #  fileName: assets_audio_player_web.dart
+    platforms:
+      android:
+        package: com.github.florent37.assets_audio_player
+        #package: .\assets_audio_player
+        pluginClass: AssetsAudioPlayerPlugin
+        #mainClass: AssetsAudioPlayerPlugin
+      ios:
+        pluginClass: AssetsAudioPlayerPlugin
+      #macos:
+        #pluginClass: AssetsAudioPlayerPlugin
+      #web:
+        #default_package: assets_audio_player_web
+      #moved to assets_audio_player_web
+      #web:
+        #pluginClass: AssetsAudioPlayerPlugin
+        #fileName: assets_audio_player_web.dart
diff --git a/settings.gradle.kts b/settings.gradle.kts
index e69de29..93bc8fc 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -0,0 +1,48 @@
+import java.util.Properties
+import kotlin.io.use
+
+pluginManagement {
+
+
+    val flutterSdkPath: String by lazy {
+        val properties = java.util.Properties()
+        // Use rootProject.file() to correctly reference local.properties from the root
+        rootDir.resolve("local.properties").inputStream().use { properties.load(it) }
+        properties.getProperty("flutter.sdk") ?: error("flutter.sdk not found in local.properties")
+    }
+
+    // Set extra property for compatibility, if needed
+    settings.extra["flutterSdkPath"] = flutterSdkPath
+    println("flutterSdkPath: $flutterSdkPath")
+
+    // This includes the Flutter Gradle build logic, which makes the Flutter plugin available
+    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")
+
+
+    repositories {
+        google()
+        mavenCentral()
+        gradlePluginPortal()
+    }
+
+    plugins {
+        //Eirik 15.05.25: Downgraded flutter from 3.29.2 to 3.22.2 due to error in flutter version
+        //AGP 8.1.0 is compatible with Flutter 3.22.2
+        //id("com.android.library") version "8.9.2"
+        id("com.android.library") version "8.1.0"
+        id("org.jetbrains.kotlin.android") version "1.9.22"
+        //id("dev.flutter.flutter-gradle-plugin")
+    }
+}
+
+dependencyResolutionManagement {
+    //repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
+    repositoriesMode.set(RepositoriesMode.PREFER_SETTINGS)
+    repositories {
+        google()
+        mavenCentral()
+        maven { url = uri("https://download.flutter.io/maven") }
+    }
+}
+
+include(":android")
